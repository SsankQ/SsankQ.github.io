[ { "title": "Database Index", "url": "/posts/06-20-CS-DB-Index/", "categories": "Computer Science", "tags": "CS, DB", "date": "2022-06-20 16:30:00 +0900", "snippet": " 참조 블로그“면접때 대답을 잘 못해서 공부해야겠다는 생각이 들었다.. 트랜잭션도 시원하게 설명 못했다.. 작성하는대로 복습할 것!”Database Index인덱스(Index)란?“데이터베이스 테이블에 대한 검색 성능 속도를 높여주는 자료구조” 데이터의 주소값을 저장하는 별도의 특별한 자료구조흔히 책의 목차(Index)에 비유하곤 한다. 원하는 데이터를 빠르게 찾을 수 있게 해준다인덱스의 가장 큰 특징은 데이터들이 정렬되어 있다는 점이다인덱스 사용 이유?정렬되어 있는 점을 살려 Full Table Scan 보다 조건 검색에 굉장한 이점을 가져오게 해준다 Full Table Scan말 그대로 테이블 전체를 탐색해 원하는 데이터를 가져오는 것 Where 절 정렬되지 않은 데이터베이스 정렬되지 않은 채 데이터들이 축적되면 데이터는 뒤죽박죽 입력되게 된다. 이때, Full Table Scan을 진행하게 된다 정렬된 데이터베이스 정렬되어 있는 데이터들로부터 가장 적합한 조건만 제시해주면 되니 훨씬 효율적이다 Order by 절 인덱스에 의해 정렬이 되면 Order by에 의한 정렬 과정을 생략할 수 있다. Order by는 부하가 많이 걸리는 작업이다이러한 전반적인 자원 소모를 줄여주게 된다 Min, Max 테이블 시작, 끝점만 찾아내면 되기에 최소, 최대값을 구하기에도 용이하다 인덱스의 단점? 정렬된 상태를 계속해서 유지해줘야 한다 검색 시에도 무조건 인덱스가 좋은 것은 아니다 전체 데이터베이스의 10 ~ 15 %이하 탐색에 권장된다인덱스를 관리하기 위해서는 데이터베이스의 10%에 해당하는 저장공간이 추가로 필요하다 “인덱스의 장단점에 대해 알아보았는 데 무조건 좋은 것이 아니기에, 데이터베이스 설계 시 인덱스 생성 전략을 잘 구상해서 설계해야겠다”" }, { "title": "SQL vs NoSQL", "url": "/posts/06-18-CS-SQLvsNoSQL/", "categories": "Computer Science", "tags": "CS, DB", "date": "2022-06-18 15:30:00 +0900", "snippet": "SQL vs NoSQLSQL(RDBMS) 데이터는 정해진 데이터 스키마에 따라 테이블에 저장 데이터는 관계를 통해 여러 테이블에 분산 각 테이블마다 명확하게 정의되어 있는 구조가 존재한다스키마를 준수하지 않는 레코드는 테이블에 추가될 수 없다NoSQL(DBMS) 스키마, 관계가 없는 것이 가장 큰 특징 Document, Collection의 명칭을 따른다 SQL과는 달리 정해진 스키마가 존재하지 않아 다른 구조의 데이터도 추가가 가능하다SQL vs NoSQL 확장(Scaling) SQL : 정해진 스키마 구조를 변경할 수 없기에, “수직적 확장”만이 가능하다 NoSQL : “수평적 확장”이 가능하다 수직적 확장데이터베이스의 성능을 향상 시키는 것 수평적 확장서버 추가 및 데이터베이스 분산을 통해 확장되는 것 SQL 장점 명확하게 정의된 스키마를 통해 데이터의 무결성 보장 관계를 맺는 것으로 데이터를 중복없이 저장 단점 NoSQL 대비 유연성이 떨어진다. 추후 수정이 힘들어진다 관계에 따른 Join을 바탕으로 복잡한 쿼리가 만들어진다 수평적 확장이 어렵다 NoSQL 장점 유연한 데이터 구조, 언제든지 데이터를 조정하고 새로운 필드 추가 가능 애플리케이션이 필요로하는 데이터 형태(JSON)를 지니기에 데이터 처리 속도가 빠르다 수직 / 수평 확장 모두 가능하다 단점 유연성으로 인한 데이터 구조 결정이 미뤄질 가능성이 있다 데이터 중복을 계속해서 업데이트해야 한다 데이터가 여러 컬렉션에 중복되어 있어 작업 시 모든 컬렉션에서 수행해야 한다 " }, { "title": "CAP 이론", "url": "/posts/06-17-CS-CAP%EC%9D%B4%EB%A1%A0/", "categories": "Computer Science", "tags": "CS, DB", "date": "2022-06-17 15:30:00 +0900", "snippet": "CAP 이론CAP이란? 관계형 데이터 모델을 지양하는 NoSQL에서 의미있는 이론이다 세가지 속성을 뜻하며 각각 일관성, 가용성, 분단 허용성을 뜻한다 분산 시스템에서는 위 3가지 속성을 모두 충족하는 것은 불가능하며, 오직 2가지만 만족할 수 있다 (CA / AP / CP)일관성(Consistency) ACID의 일관성과 같은 의미를 지닌다DB가 분산된 경우에도 하나가 수정되면 다른 DB에도 동일하게 변경되어야 한다가용성(Availability) 모든 서버는 클라이언트에게 항상 정상적인 응답을 보내줘야 한다는 특성분산된 DB에서도 특정 DB에 문제가 발생해도 다른 DB에서 정상 응답을 돌려줘야한다분단 허용성(Partition Tolerance) 지역적으로 분할되어 있는 네트워크 환경에서클러스터가 여러대 동작하고 있을 때, 해당 클러스터 간 통신이 단절되어도 시스템이 잘 작동해야한다는 특성CAP의 단점“CA, AP, CP와 같이 두 가지의 특성만 만족하기 때문에, 각 케이스에 따라 빠져있는 특성에 대한 허점이 생긴다”“특성 중 2가지만 만족할 수 있는 CAP이론을 보완하는 이론으로 PACELC 이론이 존재한다. 다음에는 이 이론에 대해서 공부하고 다루어 볼 예정이다”" }, { "title": "트랜잭션(Transaction)", "url": "/posts/06-16-CS-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/", "categories": "Computer Science", "tags": "CS, DB", "date": "2022-06-16 15:30:00 +0900", "snippet": "트랜잭션트랜잭션(Transaction)이란? 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위 하나로 묶인 작업들은 모두 실행되거나, 실행되지 않는다 (All-or-Nothing)트랜잭션의 특징 SQL은 ACID 특성을 따른다원자성 (Atomicity) 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장=&amp;gt; 불가능한 최소의 단위인 하나의 원자처럼 동작일관성 (Consistency) 미리 정의된 규칙(제약)에서만 수정이 가능한 특성데이터베이스의 상태는 이전과 같이 유효해야한다독립성 (Isoloation) 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 하는 특성트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장지속성 (Durability) 성공적으로 수행된 트랜잭션은 영원히 반영되어하는 특성기록이 영구적으로 남아있어야 한다“SQL에서는 ACID 특성을 통해 트랜잭션이 안전하게 수행된다는 것을 보장해야한다.다만 NoSQL에서는 ACID 특성과는 달리 CAP 이론을 다룬다고 한다. 어떠한 것인지 알아봐야겠다”" }, { "title": "프레임워크 vs 라이브러리", "url": "/posts/06-13-CS-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%ACvs%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/", "categories": "Computer Science", "tags": "CS", "date": "2022-06-13 16:30:00 +0900", "snippet": " 참조 블로그프레임워크 vs 라이브러리프레임워크(Framework)란? 원하는 기능 구현에 집중해 개발할 수 있도록 형태와 기능을 갖추고 있는 골격(뼈대) 앱(서버) 구동, 메모리, 이벤트 루프 등의 부분은 프레임워크가 관리, 사용자는 정해진 방식대로 구현 예시 웹 개발 : Angular, Vue.js 등 Node.js : Express, NestJS 등 라이브러리(Library)란? 특정 기능을 모와둔 코드, 함수들의 집합이며 코드 작성 시 활용 가능한 도구들을 의미 예시 JavaScript : React Node.js : npm으로 설치한 모듈 프레임워크 vs 라이브러리 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 한다 제어의 역전, IoC(Inversion of Control)" }, { "title": "동기 vs 비동기 / Blocking vs Non-Blocking", "url": "/posts/06-07-CS-%EB%8F%99%EA%B8%B0vs%EB%B9%84%EB%8F%99%EA%B8%B0/", "categories": "Computer Science", "tags": "CS", "date": "2022-06-07 14:30:00 +0900", "snippet": " 참조 블로그동기 vs 비동기호출되는 함수의 작업 완료 여부를 신경쓰는지 여부에 따라 나뉘는 개념동기 (Synchronous) 현재 진행 중인 태스크의 응답이 끝남과 동시에 다음 작업 요청 함수를 호출한 곳에서 호출되는 함수의 결과가 반환되는 것을 기다린다 작업 완료 여부를 계속해서 체크비동기 (Asynchronous) 현재 태스크의 응답이 끝나지 않더라도 다음 작업 요청, 진행 함수를 호출한 곳에서 결과를 기다리지 않고, 다른 함수(callback)에서 결과를 처리한다 작업 완료 여부를 체크하지 않음Blocking vs Non-Blocking함수 호출에 대한 제어권 처리 방식의 차이 제어권 함수(태스크)의 코드를 실행할 수 있는 권리 BlockingBlocking은 A함수가 B함수를 호출하면, 제어권 A -&amp;gt; BNon-BlockingNon-Blocking은 A함수가 B함수를 호출해도 제어권을 그대로 유지" }, { "title": "사전과제 회고", "url": "/posts/05-31-TIL-%EC%82%AC%EC%A0%84%EA%B3%BC%EC%A0%9C%ED%9A%8C%EA%B3%A0/", "categories": "TIL, 2022-05", "tags": "TIL", "date": "2022-05-31 21:30:00 +0900", "snippet": "사전 과제 내용 웹 애플리케이션 기능들 중 회원 관련 기능을 구현 후 이에 대한 테스트 코드를 작성하는 내용이었다.사용한 스택으로는 Node.js TypeScipt 기반으로 Express 서버 구축 후 MongoDB에 연결 후 비즈니스 로직을 작성하였다.테스트 코드는 Jest를 선택해 작성하였다.사전 과제 인터뷰 후 Review MVC 패턴을 통해 폴더 구성을 했는데, Controller 부분에서 직접 파일을 작성하는 것이 아니라 한단계 더 폴더를 세분화해서 작성해줄 것 사용자 인증을 위해 JWT를 사용했지만, JWT만 사용하는 것은 보안에 좋지 않으므로 Cookie Session을 활용할 것 에러 통합 핸들링하는 것도 중요하다느낀점 서버의 유저는 API를 사용하는 클라이언트 서버의 부하를 줄이기 위해 노력하는 것은 좋으나 서버의 유저를 Serving 하는 것에 초점을 두자 실제 트래픽이 있다는 가정하에 작성하자 사실, 트래픽이 없다는 전제로 보안 프로토콜을 사용하지 않고 코드를 작성했기 때문에, 이러한 점들을 지적받았다. 항상 실제 서비스를 구현한다 생각하고 개발하자이번 사전 과제를 통해 서버의 존재 의의부터 개발할 때, 어떤 점들을 신경써야하는지 배울 수 있었다. 능숙한 개발자가 되기위해 끊임없이 클라이언트의 입장에서 고민할 수 있도록 노력해야겠다" }, { "title": "객체지향 프로그래밍", "url": "/posts/05-12-CS-OOP/", "categories": "Computer Science", "tags": "CS", "date": "2022-05-12 14:30:00 +0900", "snippet": "OOP란? OOP - 객체 지향형 프로그래밍(Object-Oriented Programming) C 언어와 같은 절차 지향적인 프로그래밍이 아닌 객체 관점에서의 프로그래밍을 뜻한다 “컴퓨터 프로그래밍의 패러다임중 하나로 프로그램을 객체(object) 단위로 나누고 이를 상호작용하도록 작성하는 방법이다. 여기서 객체는 어떤 역할을 수행하는 함수와 변수의 묶음의 개념으로 본다” OOP - JavaScript JavaScript에서의 객체 지향 프로그래밍에는 대표적으로 Class와 Instance가 존재한다 Class : 일종의 원형, 하나의 모델이 되는 청사진 Class는 객체를 만들기 위한 생성자(Constructor) 함수를 포함한다 // ES6 문법 class Car { constructor(brand, name, color) { // parameter: 인스턴스 생성시 지정하는 값 this.brand = brand; // this: 인스턴스 객체를 뜻함 this.name = name; // this에 할당한다 = 만들어진 인스턴스에 값을 부여한다는 뜻 this.color = color; } } Instance : Class 즉, 청사진을 바탕으로 한 객체를 만드는 프로그래밍 패턴 function Car(color) { } // class // 보통 클래스는 대문자 + 일반명사로 만듦 /* 일반적인 함수: 적절한 동사 + 소문자 */ let avante = new Car(&#39;blue&#39;); // instances let mini = new Car(&#39;cyan&#39;); let beetles = new Car(&#39;red&#39;); JavaScript는 정확하게는 객체 지향형 언어는 아니나, 객체 지향 패턴으로 코드를 작성할 수 있다(프로토타입 기반)OOP의 주요 컨셉Encapsulation(캡슐화)데이터와 기능을 하나의 단위로 묶는 것을 뜻하며, 이를 통해 코드가 복잡하지 않게 만들고, 재사용성을 높인다 은닉화(Hiding) 구현은 숨기고, 동작은 노출시킨다 =&amp;gt; 내부 데이터나 구현이 외부로 노출되지 않도록 만드는 것 느슨한 결합에 유리하다 =&amp;gt; 언제든 구현을 수정할 수 있다 느슨한 결합 (loosing coupling): 코드 실행 순서에 따라 절차적으로 코드를 작성하는 것이 아니라, 코드가 상징하는 실제 모습과 닮게 코드를 모아 결합하는 것 Abstraction(추상화)코드가 복잡하지 않게 하고, 단순화된 사용으로 인해 변화에 대한 영향 최소화하는 것 내부 구현은 아주 복잡하지만, 실제로 노출되는 부분은 단순하게 만든다는 개념캡슐화 vs 추상화 캡슐화 코드나 데이터의 은닉에 포커스 추상화 클래스를 사용하는 사람이 필요하지 않은 메소드를 노출시키지 않고, 단순한 이름으로 정의하는 것에 포커스 Inheritance(상속)부모 클래스의 특징을 자식 클래스가 물려받는 것 =&amp;gt; 불필요한 코드를 줄여 재사용성 높임 Inheritance In JS const Grub = require(&#39;./Grub&#39;); const Bee extends Grub { // extends를 이용하여 상위 클래스에 연결 constructor() { super(); // super를 이용하여 상위 클래스로 부터 속성, 메소드를 받아옴 this.propertyA = value; this.propertyB = value; } eat() { // method 작성 } module.exports = Bee; // value값을 직접 지정할 때에는 constructor()처럼 매개변수 지정은 필요 없음 /* 매개변수를 사용하여 값을 유동적으로 바꿔주려면 * constructor(a, b) { this.propertyA = a this.propertyB = b } 형태로 사용할 것 */ /* 새로운 method를 만들 때에는 constructor 외부에 작성할 것 */ Polymorphism(다형성)객체의 변수나 메서드가 조건에 따라 다른 의미로 해석할 수 있는 것을 뜻한다 오버라이딩 기법을 사용하여 자식 클래스의 메서드가 부모 클래스의 메서드와 다르게 동작하거나 변수가 다른 값으로 지정될 수 있다 오버라이딩(Overriding) : 자바스크립트 객체의 상속받은 부모의 메소드를 재정의하는 것을 의미 자바스크립트를 사용하면서 객체 지향 프로그래밍에 대해 학습하며 핵심이 될만한 키워드를 정리해봤으나, 아직 실질적으로 체감이 되지 않는 점도 몇몇 남아있다.조금 더 구글링을 통해 OOP에 대해 알아보고 관련 강의를 찾아볼 예정이다. 다음에는 JS에서 중요한 프로토타입에 대해 정리해봐야겠다" }, { "title": "CloudFront - AccessDeniedException / CodePipeline - AccountLimitExceededException", "url": "/posts/EIF-AWS-CloudFront-Codebuild/", "categories": "EIF, Side-Project", "tags": "Side-Project, EIF", "date": "2022-05-10 21:00:00 +0900", "snippet": "어떤 에러인가? 외구님 AWS Console에서 테스트 배포 진행 중 CloudFront가 생성되지 않아 구글링을 통해 방법을 찾는데 꽤 시간이 소요됨 마찬가지로, CodePipeline에서 배포 자동화 파이프라인을 생성 후 Build 단계에서 AccountLimitExceededException 오류 발생하여 빌드가 진행되지 않음AWS 계정 자체에 limit가 낮게 설정되어 있는지, 아니면 IAM 보안 관련 이슈인지는 AWS 회신을 통해 확인 후 추가적으로 알아볼 예정이다에러 메시지 CloudFront AccessDeniedException: Your account must be verified before you can add new CloudFront resources. To verify your account, please contact AWS Support (https://console.aws.amazon.com/support/home#/ ) and include this error message. (Service: AmazonCloudFront; Status Code: 403; Error Code: AccessDenied; Request ID: ~~~) CodePipeline - Build Stage Error calling startBuild: Cannot have more than 0 active builds for the account (Service: AWSCodeBuild; Status Code: 400; Error Code: AccountLimitExceededException; Request ID: &amp;lt;x&amp;gt;) 에러 핸들링 방법 CloudFront Distributions limit를 추가할 수 있게 AWS Service Quotas에 할당량 증가 요청 Build Stage도 마찬가지로 AWS Service Quotas를 통해 할당량 증가 요청에러 핸들링을 위해 참고한 레퍼런스 링크 CloudFront AWS Report CodeBuild MI-NE 님 블로그 " }, { "title": "Side Project DevLog 05-10", "url": "/posts/05-10-TIL-DevLog/", "categories": "TIL, 2022-05", "tags": "TIL, DevLog", "date": "2022-05-10 20:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 테스트 배포 진행 보조 협업 툴 예습을 위한 JIRA 프로젝트 생성 후 Github Repo 연결 JIRA Key를 이용해 Github Commit 연결 방법 학습 애자일 - 스크럼 기법을 바탕으로 프로젝트 생성 ( 애자일에 대한 추가 학습 필요) 오늘의 프로젝트에서 힘든 점은 무엇인가요? JIRA Software 사용법이 아직 익숙치 않아 꾸준한 구글링 및 연습을 계속해야겠다 외구님 AWS Console에서 테스트 배포 진행 중 CloudFront가 생성되지 않아 구글링을 통해 방법을 찾는데 꽤 시간이 소요됨 CloudFront Distributions limit를 추가할 수 있게 AWS Service Quotas에 할당량 증가 요청 마찬가지로, CodePipeline에서 배포 자동화 파이프라인을 생성 후 Build 단계에서 AccountLimitExceededException 오류 발생하여 빌드가 진행되지 않음 이도 AWS Service Quotas를 통해 할당량 증가 요청 AWS 계정 자체에 limit가 낮게 설정되어 있는지, 아니면 IAM 보안 관련 이슈인지는 AWS 회신을 통해 확인 후 추가적으로 알아볼 예정이다참조 링크 AWS Report\\ MI-NE 님 블로그내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? AWS에서 답변 받은 후 테스트 배포 추가로 진행할 지, Vercel로 전환하여 배포 테스트 진행해볼지 결정 Server - MongoDB 연결 후 필요한 쿼리로 CRUD 구현 틀 잡기" }, { "title": "Side Project DevLog 05-09", "url": "/posts/05-09-TIL-DevLog/", "categories": "TIL, 2022-05", "tags": "TIL, DevLog", "date": "2022-05-09 18:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? Users API 문서 작성 MVC 패턴에 맞춰 폴더 구성 Route - Controller 연결 코드 작성 및 테스트 완료 서버 기본 파일 코드 작성오늘의 프로젝트에서 힘든 점은 무엇인가요? TypeScript 기반으로 Express 서버를 구현하는 데, 작성해줘야 하는 타입 부분에 대한 구글링 진행으로 생각보다 속도가 나지 않음const app: Application = express();const corsOptions: cors.CorsOptions = { origin: [&quot;http://localhost:3000&quot;], methods: [&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;UPDATE&quot;, &quot;PATCH&quot;, &quot;OPTIONS&quot;], credentials: true,}; 또한 package.json에 필요한 패키지를 받을 때에도 TypeScript에 맞게 @types로 기존 모듈을 보조해줘야하는 라이브러리를 추가해줘야 한다는 점이 생소했음 &quot;dependencies&quot;: { &quot;cors&quot;: &quot;^2.8.5&quot;, &quot;dotenv&quot;: &quot;^16.0.0&quot;, &quot;express&quot;: &quot;^4.18.1&quot;, &quot;mongodb&quot;: &quot;^4.5.0&quot;, &quot;mongoose&quot;: &quot;^6.3.2&quot; }, &quot;devDependencies&quot;: { &quot;@types/cors&quot;: &quot;^2.8.12&quot;, &quot;@types/express&quot;: &quot;^4.17.13&quot;, &quot;@types/mongodb&quot;: &quot;^4.0.7&quot;, &quot;@types/mongoose&quot;: &quot;^5.11.97&quot;, &quot;@types/node&quot;: &quot;^17.0.31&quot;, &quot;nodemon&quot;: &quot;^2.0.16&quot;, &quot;ts-node&quot;: &quot;^10.7.0&quot;, &quot;typescript&quot;: &quot;^4.6.4&quot; } 필요한 모듈은 그때마다 구글링하여 @types 확인 후 적용 필수!내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 테스트 배포 진행 보조 팀원들과 기본 기능에 대해 회의 후 API 문서 확정 API 문서 확정된 후에는 이에 맞게 코드 작성" }, { "title": "가비지 컬렉션", "url": "/posts/04-16-CS-GarbageCollection/", "categories": "Computer Science", "tags": "CS", "date": "2022-04-16 17:30:00 +0900", "snippet": "" }, { "title": "캐시", "url": "/posts/04-15-CS-Cache/", "categories": "Computer Science", "tags": "CS", "date": "2022-04-15 17:30:00 +0900", "snippet": "" }, { "title": "호이스팅과 TDZ", "url": "/posts/04-14-CS-Hoisting&TDZ/", "categories": "JavaScript", "tags": "CS, JavaScript", "date": "2022-04-14 17:30:00 +0900", "snippet": "" }, { "title": "JavaScript EventLoop", "url": "/posts/04-13-CS-EventLoop/", "categories": "JavaScript", "tags": "CS, JavaScript", "date": "2022-04-13 16:30:00 +0900", "snippet": "" }, { "title": "JavaScript는 Single Thread인가?", "url": "/posts/04-12-CS-JS-SingleThread/", "categories": "JavaScript", "tags": "CS, JavaScript", "date": "2022-04-12 20:30:00 +0900", "snippet": "" }, { "title": "Final Project DevLog 04-10", "url": "/posts/04-10-TIL-DevLog/", "categories": "TIL, 2022-04", "tags": "TIL, DevLog", "date": "2022-04-10 20:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 필름로그 및 마이로그 필름타입별 필터 기능 구현 아이디 / 비밀번호 찾기 창 구현 반응형 웹 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? 반응형 웹 구현에 맞춰 CSS 요소를 수정하고 styled-component를 다루었는데.. 간만의 CSS다보니 어색하고 어려웠다내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 코드 최종 마무리 Wiki Read.me 수정 발표 자료 준비" }, { "title": "Final Project DevLog 04-08", "url": "/posts/04-08-TIL-DevLog/", "categories": "TIL, 2022-04", "tags": "TIL, DevLog", "date": "2022-04-08 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 필름 취향 테스트 알고리즘 구현 alert 및 confirm 창 스타일 개선 이용약관 수정 비밀번호 변경 후 로그아웃되게 코드 수정 필름로그 수정 API 요청 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? 반응형 웹 구현을 보조하고자 구현하는 방법을 찾아보고 있는데, 간만에 CSS 코드를 보니 기억도 잘 안나고 쉽게 감이 잡히지 않았다내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 필름로그 카테고리 필터 기능 구현 취향 테스트 클릭 시 해당 사진 표시되게끔 기능 구현 반응형 웹 학습 후 보조 서버 측 코드 정리" }, { "title": "Final Project DevLog 04-07", "url": "/posts/04-07-TIL-DevLog/", "categories": "TIL, 2022-04", "tags": "TIL, DevLog", "date": "2022-04-07 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 엔지니어 분들과 스몰토크 진행 필름로그 댓글 엔터 이벤트 추가 필름로그 수정 기능 서버 요청 필름로그 디테일 페이지 시 한번씩 렌더링 되지 않던 점 수정 필름스팟 페이지 검색 시 키워드 주변 장소로 지도 이동 및 확대될 수 있게 코드 수정오늘의 프로젝트에서 힘든 점은 무엇인가요? 가끔씩 setState가 State를 즉각적으로 반영해주지 않던 오류가 있었는데, useRef를 통해 참조를 주는 것으로 코드 수정한 뒤로부터는 아직까지 렌더링 오류는 만나보지 못하고 있음 다만, useRef의 경우는 state를 변경하고 다시 렌더링 하지 못한다는 점이 있어서 좋아요 버튼과 같이 즉각적으로 state 변경을 반영해줘야하는 곳에서는 적절한 방법은 아니라고 한다await axios .get(`${process.env.REACT_APP_API_URL}/filmlogs/view/${filmlog_id}`, { headers: { accept: &quot;application/json&quot;, }, }) .then((res) =&amp;gt; { const detailInfo = res.data.data; if (detailInfo) { setState(detailInfo) // 1. 렌더 오류 발생하던 부분 detailRef.current = detailInfo; // 2 . 렌더 오류 해결을 위해 useRef 사용한 부분 }) 참조 블로그 , React 공식문서내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 필름 취향 테스트 알고리즘 구현 주석 정리, console.log 삭제 불필요한 변수, 모듈 import 등 코드 전반적으로 깔끔하게 정리 서버 측 코드 정리 및 API 문서 수정 반응형 웹 구현 보조" }, { "title": "Final Project DevLog 04-06", "url": "/posts/04-06-TIL-DevLog/", "categories": "TIL, 2022-04", "tags": "TIL, DevLog", "date": "2022-04-06 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 배포 환경에서 CRUD 및 소셜 로그인 테스트 완료! 좋아요 기능 구현 후 클라이언트 렌더링 비밀번호 변경 이후오늘의 프로젝트에서 힘든 점은 무엇인가요? 배포 테스트 도중 클라 - 서버 간 요청 이후 데이터베이스 관련 요청이 이루어지지 않았던 점 sequelize-cli 명령어 및 model query 또한 작동되지않아 한참 찾음 devDependency에 있는 sequelize 모듈 또한 dependencies로 이동 AWS 파라미터 스토어에 환경변수가 빠진게 있었고, 값이 잘못된 것도 있어서 수정하니 해결 완료… 꼼꼼히 살피도록 해야겠음 내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 엔지니어 분들과 스몰토크 진행 Top3 현재 view 기준으로 되어있는 것 LikesCount 기준으로 변경할 것! (3가지만 가져올 수 있게) 필름 취향 테스트 구현 보조 전체 코드 확인해보면서 필요없는 주석 삭제 및 코드 정리" }, { "title": "Final Project DevLog 04-05", "url": "/posts/04-05-TIL-DevLog/", "categories": "TIL, 2022-04", "tags": "TIL, DevLog", "date": "2022-04-05 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 유저 정보 수정 API 요청 구현 (프로필, 닉네임, 휴대폰, 비밀번호) 서버 비밀번호 변경 라우터 추가 및 기능 구현 필름로그 / 마이로그 무한스크롤에 맞춰 API 요청 기능 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? 무한스크롤 구현 시, DOM Element로 구현했을 경우 스크롤 위치에 따라 API 요청이 계속해서 진행되는 문제가 발생 (또한, DOM Element로 구현 시, 모바일 반응형 웹과 일반 웹에서 무한 스크롤 트리거 위치가 일치하지 않다고 한다)const scrollEvent = useCallback(() =&amp;gt; { const { innerHeight } = window; const { scrollHeight, scrollTop } = document.documentElement; if (Math.round(scrollTop + innerHeight) &amp;gt;= scrollHeight &amp;amp;&amp;amp; !end) { setPage((prev) =&amp;gt; prev + 1); // &amp;lt;&amp;lt;&amp;lt;&amp;lt; 특정 위치에 도달하면 page가 올라가는 방식이었으나, 특정 구간에서 너무 많이 반응해 page 번호가 계속 올라감 } }, [page]); useEffect(() =&amp;gt; { window.addEventListener(&quot;scroll&quot;, scrollEvent); return () =&amp;gt; { if (end) { window.removeEventListener(&quot;scroll&quot;, scrollEvent); } }; }, [scrollEvent]); 위 문제점들로 인해 기존에 외구님이 구현하셨던 IntersectionObserver 기능으로 다시 구현내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 배포 환경 테스트 필수!! 지도 API 요청 마커에서 활용할 수 있는 정보 찾아서 마커 클릭 이벤트 구현해보기" }, { "title": "Final Project DevLog 04-04", "url": "/posts/04-04-TIL-DevLog/", "categories": "TIL, 2022-04", "tags": "TIL, DevLog", "date": "2022-04-04 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 필름로그 및 필름토크 CRUD 클라 - 서버 요청 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? 무한스크롤에 페이지네이션 형식으로 서버에 데이터를 받아와야하는데 state로 지정해둔 offset이 set함수로도 갱신되고 있지 않아 원인을 찾아 해결하거나 다른 방식으로 구현해야겠음 // 타겟 찾기 const onIntersect = async ([entry], observer) =&amp;gt; { if (entry.isIntersecting &amp;amp;&amp;amp; !isLoaded) { observer.unobserve(entry.target); await getMoreItem(); observer.observe(entry.target); } }; const getMoreItem = async () =&amp;gt; { setIsLoaded(true); await new Promise((resolve) =&amp;gt; setTimeout(resolve, 1000)); getFilmLogDateByPagination(offset, 8); setIsLoaded(false); };const getFilmLogDateByPagination = (offset, limit) =&amp;gt; { axios .get( `${process.env.REACT_APP_API_URL}/filmlogs/total/?offset=${offset}&amp;amp;limit=${limit}`, { headers: { Accept: &quot;application/json&quot;, }, } ) .then((res) =&amp;gt; { if (res.data.data) { setItemLists((itemLists) =&amp;gt; itemLists.concat(res.data.data)); } setOffset((offset) =&amp;gt; offset + 8); // resolve 이후 set함수가 진행되지 않음 }) .catch((err) =&amp;gt; console.log(err)); };내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 무한스크롤 로딩 해결 배포 환경에 접근할 수 있게되면 서버 도메인이 잘 반영되지 않는점 체크해보기" }, { "title": "Final Project DevLog 04-01", "url": "/posts/04-01-TIL-DevLog/", "categories": "TIL, 2022-04", "tags": "TIL, DevLog", "date": "2022-04-01 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 데이터베이스로부터 필름토크 정보 불러와 페이지네이션으로 표현 필름토크 등록, 삭제, 조회 클라-서버 요청 부분 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? React-Quill 사용 시, 이미지를 다루는 부분에서 DOM을 다루게 되어 많은 구글링 후에 구현이 가능했다const imageHandler = () =&amp;gt; { const input = document.createElement(&quot;input&quot;); input.setAttribute(&quot;type&quot;, &quot;file&quot;); input.setAttribute(&quot;accept&quot;, &quot;image/*&quot;); input.click(); input.onchange = async () =&amp;gt; { console.log(input); if (input.files) { const file = input.files[0]; const formData = new FormData(); formData.append(&quot;image&quot;, file); axios .post( `${process.env.REACT_APP_API_URL}/filmtalks/register/image/${userInfo.id}`, formData, { headers: { &quot;Content-type&quot;: &quot;multipart/form-data&quot;, }, } ) .then((res) =&amp;gt; { const { url } = res.data; const range = quillRef.current.getEditor().getSelection().index; if (range !== null &amp;amp;&amp;amp; range !== undefined){ let quill = quillRef.current.getEditor(); quill.setSelection(range, 1); quill.clipboard.dangerouslyPasteHTML(range, `&amp;lt;img src=${url} alt=&quot;미리보기&quot; /&amp;gt;`) } }) .catch((err) =&amp;gt; console.log(err)); } }; };내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 필름토크 수정 클라-서버 요청 구현 및 부족한 부분 보충 취향 테스트, 추천에 필요한 정보 수집" }, { "title": "Final Project DevLog 03-31", "url": "/posts/03-31-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-31 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 클라이언트 - 서버간 Axios 요청을 통해 필름로그 등록 후 조회 기능 구현 교육 엔지니어님들과 스몰토크 진행오늘의 프로젝트에서 힘든 점은 무엇인가요? 클라이언트 코드를 보고 단번에 이해하기 힘든 부분들이 몇몇 있었고, 이를 키워드 삼아 복습할 필요성을 느낌 서버 측 코드 또한 정리가 필요하다 느껴짐내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 배포 소스코드 반영 후 잘 적용되는지 테스트 보조 주말 날씨를 불러오기 위한 날짜 적용 및 날씨 API 요청 방법 찾아보기 지도 API를 통해 활용할 수 있는 기능 구상 더 해보기" }, { "title": "Final Project DevLog 03-30", "url": "/posts/03-30-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-30 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 카카오 소셜 로그인 기능 구현 클라이언트 측에서 redirecturi를 이용해 Authorization Code 받아오고 이를 통해 로컬 서버에 요청 서버 측에서는 리소스 서버에 요청 보내 토큰 및 사용자 정보 조회 이후, 서버에서 DB에 해당 정보 저장과 동시에 jwt 토큰을 생성해주어 클라이언트에 전달 클라이언트는 토큰 정보를 바탕으로 유저 정보 및 로그인 상태 갱신 오늘의 프로젝트에서 힘든 점은 무엇인가요? Oauth 요청 부분을 구현하는 데 전에 학습했던 내용이 잘 기억나지않아 다시금 살펴보며 진행하느라 구현에 생각보다 시간이 소요됨 전체 플로우 복습 필요성을 느낌내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 클라이언트에서 필요한 부분에 각 API 요청을 보낼 수 있게 보조 카카오 지도 API 구현 부분 학습 필름토크 부분에 도입된 React-quill을 바탕으로 클라 - 서버 간 통신이 어떻게 이루어지는지 테스트" }, { "title": "Final Project DevLog 03-29", "url": "/posts/03-29-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-29 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 필름 정보 수집 후 노션에 정리 클라이언트 무한 스크롤 기능 구현 보조 카카오 소셜 로그인 구현을 위해 애플리케이션 등록 및 기본적인 플로우 학습오늘의 프로젝트에서 힘든 점은 무엇인가요? 테스트 등 서비스에서 사용해야할 필름 정보들이 아직 부족한 것 같아 좀 더 정보를 모아 깔끔히 정리할 필요성을 느낌 소셜 로그인 전체 플로우가 전부 기억나지는 않아 추가적으로 복습 진행할 예정내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 카카오 공식 문서를 통해 소셜 로그인 구현 시도 클라 - 서버 간 필요한 환경 변수를 다시 한번 정리해볼 예정" }, { "title": "Final Project DevLog 03-28", "url": "/posts/03-28-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-28 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 필름로그 CRUD 구현 필름로그 / 토크 댓글 CRUD 구현 클라 - 서버 간 이미지 요청을 위해 axios, multer, express.static 테스트 완료오늘의 프로젝트에서 힘든 점은 무엇인가요? formdata에 대해 바로 이해가 되지않아 좀 더 공부가 필요하다 생각들었습니다. 단순히 CRUD 구현 뿐만 아니라 다방면으로 상황을 살펴보며 조건을 넣어줘야해서 좀 더 디테일하게 조건을 나눠볼 예정입니다내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 무한스크롤에 필요한 페이지네이션을 구현해 클라이언트에 전달되게끔 코드 수정 구현한 CRUD에 가감할 부분 있는지 다시 한번 체크 후 API 문서 최신화 테스트, 더미데이터를 위한 필름 정보 검색" }, { "title": "Final Project DevLog 03-25", "url": "/posts/03-25-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-25 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 유저 프로필, 필름로그, 필름토크용 각 이미지 저장공간 별도로 확보 주 단위 데이터 가져오기 기능 구현 좋아요 On / Off 기능 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? 주 단위로 끊어서 데이터 통계 내는 기능을 구현하는 중에 new Date() 객체 사용 시, 적용할만한 메소드를 찾는 데 다소 시간이 소요됨 또한, 기본 시간이 UTC로 설정되어 있어서 GMT +09:00 에 맞춰 코드를 작성하는 부분이 “약간” 까다로웠음 오늘 구현한 기능들이 효율적인 방법인지에 대해 고민해볼 필요가 있다 느껴짐주말 간 프로젝트에 기여하기 위해 무엇을 해야 하나요? 좋아요 카운트 업 기능 구현 주 단위 데이터 가져올 때 Top 3 가져오기 위해 model.max 등의 함수 활용해보고 테스트 필름로그 CRUD" }, { "title": "Final Project DevLog 03-24", "url": "/posts/03-24-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-24 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? express.static을 활용해 클라이언트에 정적 파일 렌더링 multer를 활용해 DB에 이미지 경로 저장 Sequelize 테이블 간 관계 및 FK 참조 설정 담당 엔지니어 분들과 스몰토크 진행오늘의 프로젝트에서 힘든 점은 무엇인가요? multer 사용법이 익숙하지 않아서 플로우에 대해 추가 학습할 예정 진행한 태스크 외 구상해야되는 부분들의 방법이 아직 뚜렷하게 생각나지 않아 윤곽부터 잡아가며 다시 기능을 구상해볼 예정내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 테스트를 위한 DB 시드 파일 생성 주 단위로 DB에 요청 보내 Count 가져오는 기능 구상 좋아요 기능 구상" }, { "title": "Final Project DevLog 03-23", "url": "/posts/03-23-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-23 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 최종 Wiki 수정 마무리 후 변경사항에 대해 담당 엔지니어분께 공지 Image DB에 저장 기능 구현 저장한 Image Client에 렌더링 하는 기능 구현 위치 기반 날씨 정보 받아오기 기능 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? Client에 이미지 정보를 렌더링하기 위해 express.static을 사용했는데, 이 방법 외에 Blob 타입을 buffer - base64 형식으로 변환하여 가져오는 방법이 구현하기 쉽지 않아, 추가적으로 찾아볼 예정내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 일정 주기 단위로 데이터베이스에 요청을 보내 특정 구간 내의 데이터를 가져오는 방법 구상 일정에 맞춰 담당 엔지니어분과 스몰토크를 진행하기 위해 팀원들에게 내용 공지 날씨 정보 중에서 필름 추천에 필요한 사항 찾아보기" }, { "title": "Final Project DevLog 03-22", "url": "/posts/03-22-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-22 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? Read.me 파일 수정 SR 변경 사항에 맞춰 Requirements, Sitemap, FlowChart 등 Wiki 최신화오늘의 프로젝트에서 힘든 점은 무엇인가요? First Project 때와는 다르게 태스크 분배 및 SR 기획 범위 잘 조정하지 못해 SR 기획 기간이 더 길어짐 미리 기획이 잘된 팀은 코드 작성 단계를 밟고 있을텐데 그러지 못해 아쉬움내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? SR 마무리 후 코드 작업 진행 DB에 이미지 파일 넣기 위한 방법 모색" }, { "title": "Final Project DevLog 03-21", "url": "/posts/03-21-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-21 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? SR 기획 단계 문제점을 짚고 다시금 팀원들과 브레인스토밍을 통해 프로젝트의 정체성을 다짐 엔지니어 분과의 SR 피드백을 진행하기 위해 팀원들에게 시간 공지오늘의 프로젝트에서 힘든 점은 무엇인가요? 나름 알차게 기획을 준비해 SR 피드백을 요청했는데 생각보다 허점이 많았음 주말 간 컨디션 관리가 완벽하지 않아 금일 태스크 진행에 힘들점이 있었음내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? SR 기획에서 부족했던 점을 보충하고 Wiki 등을 다시 수정할 예정 금일 진행한 아이디어 회의에 맞춰 스키마 디자인도 수정할 예정" }, { "title": "Final Project DevLog 03-18", "url": "/posts/03-18-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-18 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 배포 자동화 파이프라인 구축 후 테스트 배포 진행 Sequelize 활용해 MySQL 작업 시 Timestamp 조정 시도오늘의 프로젝트에서 힘든 점은 무엇인가요?config.js에서 timezone 옵션으로 데이터베이스 삽입 시의 시간 조정은 진행했으나,model query 진행 시의 시간은 아직 조정할 방법이 필요해서 좀 더 찾아봐야함내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 주말을 활용해 월요일 원활한 진행을 위한 충전 시간을 가질 예정 주말동안 필요한 작업, 공부 예정" }, { "title": "Final Project DevLog 03-17", "url": "/posts/03-17-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-17 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? SR 기획 Home / Requirements 작성 API 문서 작성 및 수정오늘의 프로젝트에서 힘든 점은 무엇인가요? 유저 시점에서 이해하기 쉽게 프로젝트 소개글을 쓰기 위해 시간이 상당히 소비됨 SR 기획 중 게시글 작성 페이지에서 DB와 연결되는 개념을 정립하는 것이 어려웠음내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? SR 피드백 요청 KPT 회고 링크 공유 테스트 배포 진행" }, { "title": "Final Project DevLog 03-16", "url": "/posts/03-16-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-16 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? SR 기획 사이트맵 작성 시스템 아키텍쳐 작성 API 문서 작성 플로우차트 작성 Github Wiki 작성오늘의 프로젝트에서 힘든 점은 무엇인가요? DB 스키마 설계 시 필요한 테이블, 필드, 관계 설정 유저 플로우 작성 시 전체적인 흐름을 맞추는 데 시간이 꽤 소요됨내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? SR 기획단계 마무리 Github Wiki, Readme.md 작성 기타 필요한 사항들 팀원들과 정리 후 SR 피드백 요청" }, { "title": "Final Project DevLog 03-15", "url": "/posts/03-15-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-15 21:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 프로젝트 아이디에이션 github에 필요한 이슈, PR 템플릿 구성 Client : CRA 적용 Back: 서버 app 파일 작성 및 일부 필요한 모듈 설치오늘의 프로젝트에서 힘든 점은 무엇인가요? 추후에 수정할 일 없게끔 하기위해 최대한 디테일하게 기획을 짜야하다보니 몇몇 사항들을 쉽게 결정하기 어려웠음내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? SR 기획 단계 마무리 사이트맵, 유저 플로우 작성 DB schema, API 문서 작성" }, { "title": "HTTPS 서버 배포를 위한 ELB 생성 및 ACM 인증서 발급", "url": "/posts/03-08-TIL-ACM/", "categories": "TIL, 2022-03", "tags": "TIL", "date": "2022-03-08 13:30:00 +0900", "snippet": "ELB / ACMELBACMACM 인증서 발급 구매한 도메인을 입력하여 인증서 요청 요청 후 구입한 도메인에 CNAME 이름과 값을 적용하기 위해 freenom에서 Manage DNS로 이동 후 Records에 Name, Type, Target 필드를 채워준다 정상적으로 값을 입력하고나면 AWS ACM에서 확인 후 발급 완료 freenom으로 도메인 구매 후 ACM에 인증서 발급받는 과정" }, { "title": "Module not found - Error Can&#39;t resolve &#39;fs&#39; , &#39;net&#39;", "url": "/posts/03-07-EIF-Can't-resolve-fs/", "categories": "EIF, First-Project", "tags": "First-Project, EIF", "date": "2022-03-07 23:20:00 +0900", "snippet": "EIF어떤 에러인가? S3 정적 웹 페이지 호스팅 단계에서 버킷에 넣어줄 빌드 파일을 생성하기 위해 npm run build를 실행했으나, 에러가 발생하며 진행되지 않음에러 메시지Module not found: Error: Can&#39;t resolve &#39;fs&#39; , &#39;net&#39; in [파일 경로]위와 같은 에러 메시지가 출력되어 찾아보니 공식문서에서 다음과 같은 부분을 볼 수 있었다참조한 내용으로 보아 webpack 5부터는 fs, net 등의 핵심 Node.js 모듈을 자동으로 폴리필을 지원하지 않으므로 필요한 모듈은 직접 npm을 통해 설치하여 사용하라는 뜻으로 보인다 폴리필(polyfill)웹 개발에서 기능을 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 뜻한다에러 핸들링 방법!! 작업 중인 폴더 및 파일을 보존하고 싶으시면 복사를 하는 등의 방법으로 진행하시길 권장드립니다사실 현걸님 로컬에서는 잘 빌드되지 않았는데 내 로컬에서는 빌드되어 빌드파일을 압축해서 드렸다… npm run eject 명령어 실행 npm run ejectCRA(Create-React-App)에서 위 명령어를 실행하면 숨겨진 파일까지 모두 꺼내 파일을 직접 수정, 조회할 수 있게 된다단, 한번 명령어를 실행하게 되면 취소가 불가능해지게 되니 필요할 때에만 신중히 진행할 것! Are you sure you want to eject? This action is permanent.(y/N) 와 같은 메시지가 출력된다.수락하면 다음과 같이 숨어서 리액트에 대한 기본적인 기능(Scripts 실행 및 webpack 등등)에 대한 파일들이 쭉 나타나게 된다 생성된 파일 중 webpack.config.js 파일에 다음과 같은 내용을 추가해주면 된다node : { &#39;fs&#39;: empty, &#39;net&#39;: empty,} 수정이 끝난 후에는 필요한 작업을 진행 후 생성된 config, scripts, node_modules 등 추가 및 변경된 사항을 모두 삭제하고 다시 npm install로 다시 필요한 모듈을 받아준다에러 핸들링을 위해 참고한 레퍼런스 링크Webpack 공식문서참조 사이트" }, { "title": "First Project DevLog 03-07", "url": "/posts/03-07-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-07 20:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 기본적인 배포 환경 구성 AWS EC2, S3, RDS를 활용한 배포 진행 보조오늘의 프로젝트에서 힘든 점은 무엇인가요? SR 단계에서 기능에 대한 구현 방안을 상세하게 결정짓지 못해 도중에 회의 및 수정을 반복했던 점 개발 환경과 프로덕션 단계의 환경 세팅을 달리해야했던 점 AWS 콘솔 활용도가 능숙하지 못했던 점내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? ELB, ACM을 활용해 HTTPS 서버 배포 S3 버킷에 도메인을 적용해 배포 배포 자동화 시도" }, { "title": "참조한 FK Column이 터미널에서 식별되지 않는 점 및 Sequelize unknown column 에러에 관한 내용", "url": "/posts/03-05-EIF-Sequelize-unknown-column/", "categories": "EIF, First-Project", "tags": "First-Project, EIF", "date": "2022-03-05 22:30:00 +0900", "snippet": "EIF어떤 에러인가? migration skeleton 파일을 생성하여 addColumn, addConstraint으로 컬럼 및 제약을 생성해주었고, mysql 상에서는 KEY - MUL 을 확인했으나 테이블에 models.create로 Insert할 때 FK로 설정된 user_id에 원하는 값이 Insert되지 않고 NULL 값만 출력, 터미널에서도 user_id 필드가 식별되지 않음const planData = await plans.create({ plan1, plan2, plan3, user_id: userId });Executing (default): INSERT INTO `plans` (`id`,`plan1`,`plan2`,`plan3`,`createdAt`,`updatedAt`) VALUES (DEFAULT,?,?,?,?,?);에러 핸들링 방법 models/index.js에 직접 sequelize.models 를 불러와 관계에 따라 foreign key 참조하게 설정 users.hasMany(plans, { foreignKey: &quot;user_id&quot;});plans.belongsTo(users, { foreignKey: &quot;user_id&quot;}); migration 파일에 addColumn 부분을 지우고 addConstraint로 제약만 생성해준 것으로 해결 await queryInterface.addConstraint(&quot;plans&quot;, { fields: [&quot;user_id&quot;], type: &quot;foreign Key&quot;, name: &quot;FK_plans_users&quot;, references: { table: &quot;users&quot;, field: &quot;id&quot;, }, onDelete: &quot;cascade&quot;, onUpdate: &quot;cascade&quot;, }); 모델 간의 관계를 설정해주면서 참조할 키를 지정해준 뒤, 관계에 대한 제약을 생성해주는 것이 올바른 방법인 듯하다 에러 및 원활히 진행되지 않던 점에 대한 추측 각 모델 파일 및 index.js에서 모델 간의 관계만 설정해주더라도 sequelize-cli 상에서 관계에 따라 자동으로 column이 생성되었고, 터미널의 Executing 쿼리 부분에서 추가하지 않았던 userId가 비춰지는 것 같았다 관계 설정을 올바르게 하지않고, 참조할 키를 지정 안해주면 예상했던 거와는 다르게 unknown column이 생성되어 에러가 발생하는 듯 하다 즉, 자동으로 생성되는 userId와 같은 컬럼을 타겟으로 제약을 걸어주거나, 관계 설정할 때 참조할 키를 제대로 지정을 해준 뒤 제약을 걸어줘야 올바르게 FK 참조하는 관계 설정이 완료되는 듯하다. 이 부분은 추후 마저 알아볼 예정이다에러 핸들링을 위해 참고한 레퍼런스 링크Agora states" }, { "title": "First Project DevLog 03-04", "url": "/posts/03-04-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-04 20:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 휴대폰 번호 유효성 검증을 위한 함수 구현 회원정보 수정 기능 구현 서버 플로우 부분을 고려해 상의 후 스키마 디자인 변경오늘의 프로젝트에서 힘든 점은 무엇인가요? 회원정보 관련 기능 추가 후 플래너 작성 구현 부분에서 관계 설정한 FK가 업데이트 되지 않는 상황이 발생 올바르게 관계 설정을 했다고 생각했으나 FK 설정이 mysql 상에서 비춰지지 않은 점const userId = req.params.id;const planData = await plans.create({ plan1, plan2, plan3, user_id: userId });console.log(planData);위 코드대로 실행해본 결과 터미널에는Executing (default): INSERT INTO `plans` (`id`,`plan1`,`plan2`,`plan3`,`createdAt`,`updatedAt`) VALUES (DEFAULT,?,?,?,?,?);와 같이 생성된 user_id가 식별이 되지않고 NULL 값만 데이터베이스에 추가되는 것을 확인할 수 있었다아직 위 부분 해결을 위해 방법을 구상 중이다내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? FK에 올바른 값이 적용되도록 sequelize 공식 문서 및 구글링 배포 전략 수립 예정" }, { "title": "ERR HTTP HEADERS SENT", "url": "/posts/03-04-EIF-ERR-HTTP-HEADERS-SENT/", "categories": "EIF, First-Project", "tags": "First-Project, EIF", "date": "2022-03-04 20:30:00 +0900", "snippet": "EIF어떤 에러인가? 서버가 클라이언트에 응답을 둘 이상 돌려줄 때 발생한 오류 이미 응답을 한번 했음에도 추가적인 응답을 돌려줄 때 발생에러 메시지[ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client에러 핸들링 방법 한번의 요청에 둘 이상의 응답이 발생하지 않게 조건에 맞춰 올바르게 return 작성if (password) { if (!validatePW(password)) { return res.status().send() }}res.status().send()" }, { "title": "First Project DevLog 03-03", "url": "/posts/03-03-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-03 20:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 회원가입, 로그인, 로그아웃, 사용자 정보 조회 기능 구현 유효성 검사를 위한 함수 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? sequelize-cli 명령어를 통해 PK - FK 연결하는 데 시간이 소요되었다 관계 설정이 익숙치 않아 구글링을 통해 좀 더 손쉽게 구현할 수 있는 방법을 찾아봐야겠다내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 현재 서버를 실행하면 No Sequelize instance passed 에러가 발생하니 이를 해결 플래너 작성 후 users 테이블에 연결된 FK를 업데이트 하는 기능 모색" }, { "title": "No Sequelize instance passed", "url": "/posts/03-03-EIF-No-sequelize-instance-passed/", "categories": "EIF, First-Project", "tags": "First-Project, EIF", "date": "2022-03-03 19:30:00 +0900", "snippet": "EIF어떤 에러인가? sequelize-cli 명령어를 통해 관계 설정에 따라 FK를 생성, 참조하고 난 후, 서버 실행하니 에러와 함께 서버 실행 실패에러 메시지Error: No Sequelize instance passed at Function.init (/home/hyeongyu/codestates/project/33Plan/server/node_modules/sequelize/lib/model.js:659:13) at module.exports (/home/hyeongyu/codestates/project/33Plan/server/models/bads.js:18:8) at /home/hyeongyu/codestates/project/33Plan/server/models/index.js:24:54 at Array.forEach (&amp;lt;anonymous&amp;gt;) at Object.&amp;lt;anonymous&amp;gt; (/home/hyeongyu/codestates/project/33Plan/server/models/index.js:23:4)에러 핸들링 방법 구글링했을 때 sequelize instance를 초기화하지 못한다는 말을 힌트 삼아 인스턴스 생성하는 각 models.init에 문제가 발생함을 발견 에러 원인 테이블 간 관계를 정의하고 FK를 생성, 참조하기 위해 init 부분에 생성할 초기 Column을 모아놓은 객체를 삭제했던 것이 원인 init(attributes: ModelAttributes&amp;lt;model, any&amp;gt;, options: InitOptions&amp;lt;model&amp;gt;): typeof model attributes에 필요한 인자를 지정해줘야하고 넣을 데이터가 없더라도 빈 객체를 할당해줬어야 한다 // 에러 발생good.init( { sequelize, modelName: &quot;good&quot;, } ); return good;// 에러 해결good.init( {}, { sequelize, modelName: &quot;good&quot;, } ); return good;에러 핸들링을 위해 참고한 레퍼런스 링크 Stack Overflow" }, { "title": "First Project DevLog 03-02", "url": "/posts/03-02-TIL-DevLog/", "categories": "TIL, 2022-03", "tags": "TIL, DevLog", "date": "2022-03-02 20:30:00 +0900", "snippet": "오늘은 어떻게 프로젝트에 기여했나요? 태스크 카드 작성 및 분배 Server Side에서 MVC 패턴 형식으로 폴더 구성 사설 인증서를 이용한 HTTPS 서버 구현오늘의 프로젝트에서 힘든 점은 무엇인가요? Router를 통해 Controller로 연결해주는 부분에서 기존의 CommonJS와 ES6 문법 사이에서 많이 헷갈렸습니다 ES6 문법에 따라 import하는 경우에는 package.json에 type: module을 추가해줘야한다는 것을 알게 되었습니다 또한 ES6로 import하는 것에 Directory 형식은 지원하지 않았기에 일일이 파일까지 경로를 지정해줘야했습니다. CommonJS 형식에 맞춰 폴더를 구성하였기에 프로젝트 완료 후 ES6로 리팩토링도 시도해봐야겠습니다// CommonJSconst a = require(&#39;a&#39;);module.exports// ES6import a from &#39;a&#39;;export default내일은 프로젝트에 기여하기 위해 무엇을 해야 하나요? 생성된 MVC 모델의 관계 설정" }, { "title": "ES6 import 형식으로 디렉토리를 불러올 때 발생하는 오류", "url": "/posts/03-02-EIF-ES6-import/", "categories": "EIF, First-Project", "tags": "First-Project, EIF", "date": "2022-03-02 17:30:00 +0900", "snippet": "EIF어떤 에러인가? CommonJS 형식이 아닌 ES6 import 형식으로 Directory를 불러올 때 정상적으로 불러오지 못하며 에러가 발생에러 메시지Directory import &#39;폴더 경로&#39; is not supported resolving ES modules imported from &#39;폴더 경로&#39;Did you mean to import &#39;상세 파일 경로&#39;?에러 핸들링 방법 디렉토리를 지정해주면 import Error가 발생하므로 상세 파일까지 직접 지정했더니 해결되었다 위 방법 말고도 CommonJS 형태로 변경하여 require를 통해 불러오는 것으로도 해결할 수 있었다에러 핸들링을 위해 참고한 레퍼런스 링크 https://github.com/sveltejs/kit/issues/612stack over flow" }, { "title": "Project Software Requirement 작성", "url": "/posts/03-01-TIL-Project/", "categories": "TIL, 2022-03", "tags": "TIL", "date": "2022-03-01 20:30:00 +0900", "snippet": "SR 기획FrontEnd Flow Chart 생성 사용 툴 : miroBackEnd 스키마 디자인(Schema Design) 사용 툴 : dbdiagram API 문서 작성 사용 툴 : Gitbook 아키텍쳐 다이어그램 작성(Architecture Diagram) 사용 툴 : CloudCraft" }, { "title": "Project 대비 Github 세팅", "url": "/posts/02-28-TIL-Git-project/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-28 22:30:00 +0900", "snippet": "이슈 템플릿 제작 후 이슈 카드 생성 마크다운 문법을 활용하여 체크리스트 혹은 여러 작업 진행마일스톤 생성하여 이슈 카드와 연결 Assign으로 담당할 작업자 배분 Label을 이용한 태그 부여 PR과 연결하여 merge 후에 close 될 때 해당 태스크 수행되는 것 확인 PR에 따라 마일스톤 진행도 변화되는 것 확인 베이직 칸반 보드를 활용하여 프로젝트 보드에 카드 추가 Task 관련 Project에 To Do, Not To Do 리스트 추가, 에러 핸들링 컬럼 생성 KPT 회고와 관련한 Project 보드 생성 후 이슈 카드 추가 마일스톤 연결 Dev Log Project 생성으로 하루 일지 관리할 보드 생성 " }, { "title": "EC2 인스턴스에서 서버가 실행되지 않는 문제", "url": "/posts/EIF-EC2-server/", "categories": "EIF, AWS", "tags": "AWS, EIF", "date": "2022-02-26 17:30:00 +0900", "snippet": "EIF같이 프로젝트를 진행할 팀원께서 AWS를 이용한 배포를 연습하기 위해 EC2 인스턴스 상에서 서버를 실행하는 것을 연습하고 계셨는데 연습으로 사용할 Repository의 서버가 실행되지 않는 문제가 발생했다sh: 1: node: not foundnpm ERR! Linux 4.4.0-1128-awsnpm ERR! argv &quot;/usr/bin/nodejs&quot; &quot;/usr/bin/npm&quot; &quot;start&quot;npm ERR! node v4.2.6npm ERR! npm v3.5.2npm ERR! file shnpm ERR! code ELIFECYCLEnpm ERR! errno ENOENTnpm ERR! syscall spawnnpm ERR! server@1.0.0 start: `node app.js`npm ERR! spawn ENOENTnpm ERR! npm ERR! Failed at the server@1.0.0 start script &#39;node app.js&#39;.npm ERR! Make sure you have the latest version of node.js and npm installed.npm ERR! If you do, this is most likely a problem with the server package,npm ERR! not with npm itself.npm ERR! Tell the author that this fails on your system:npm ERR! node app.jsnpm ERR! You can get information on how to open an issue for this project with:npm ERR! npm bugs servernpm ERR! Or if that isn&#39;t available, you can get their info via:npm ERR! npm owner ls servernpm ERR! There is likely additional logging output above.npm ERR! Please include the following file with any support request:npm ERR! /home/ubuntu/im-sprint-practice-dep문제 찾기에러 코드 확인 npm ERR! node v4.2.6 npm ERR! npm v3.5.2현 시점 기준으로 node, npm 버전이 낮은 걸 알게 되었고 이를 확인하려 했는데, 이상하게도 node 버전은 v17.6.0으로 확인이 되었다버전은 최신화되어 있었기에, 조금 더 하단을 살펴보니 npm ERR! code ELIFECYCLE npm ERR! errno ENOENT이러한 에러 코드를 출력하고 있었고, 바로 검색해보았다해결하기 위해 해본 것들1. 에러 코드 구글링 npm ERR! code ELIFECYCLE npm ERR! errno ENOENT이 부분을 구글링 해본 결과, 쌓인 cache를 정리하고 기존 모듈과 package.json을 삭제한 뒤 npm install &amp;amp; start를 실행해보라 하였다     a. 캐시정리     npm cache clean --force     b. 기존 파일 삭제     rm -rf ./node_modules     rm -rf ./package-lock.json     c. npm 재설치 및 재시작     npm install &amp;amp;&amp;amp; npm start  이 방법을 진행하면서 ‘EC2를 설치한 직후인데 쌓인 캐시로 문제가 발생하는게 맞을까’하고 의문이 들었고 역시나 이 방법으로는 같은 에러를 출력하며 해결되지 않았다2. node 버전 최신화   인스턴스에는 v17.6.0으로 나와있었고, 내 로컬에서도 똑같이 진행해보았는데, 같은 버전으로 서버가 잘 실행되었다3. npm 버전 최신화  이것저것 살펴보다 시간이 생각보다 지나버려서, 다시금 찬찬히 에러코드를 살펴보았다   npm 버전에도 혹시 문제가 있나해서 이 부분도 조정하니 에러가 해결되며 서버가 잘 실행되었다     (사실, 인스턴스 새로 설치하면서 처음부터 버전 잘 짚어보며 설치했다…)“위 방법 외에도 설치한 ubuntu 버전이 16.04이었기에 인스턴스 버전도 새로 맞춰서 생성해보기도 하고, node 버전을 lts로 조정도 해보고 이것저것 많이해보았지만 npm, node 버전 모두 체크해줘야 하는 것이 해결 방법이었다는 것을 조금 늦게 알게되었다.. 사실 npm ERR! Make sure you have the latest version of node.js and npm installed 부분에서 힌트는 주고 있었는데, 에러코드를 살펴보지않고, 바로 검색만 했던 것으로 시간이 훨씬 더 소비되었다”발견점“에러도 꼼꼼히 살피는 것은 물론, 에러가 발생했다고 당황해서 기본적인 부분을 놓치고 있는 것이 아닌지 다시 한번 되짚어보는 습관을 들여야겠다”" }, { "title": "AWS Pipeline 진행 중 발생한 오류 정리", "url": "/posts/EIF-AWSDeploy/", "categories": "EIF, AWS", "tags": "AWS, EIF", "date": "2022-02-21 21:00:00 +0900", "snippet": "EIF (Error I Faced)AWS, Github을 연결하여 서버 배포 자동화하는 실습 도중 발생한 오류를 정리해보았다UnknownError “CodeDeploy agent was not able to receive the lifecycle event. Check the CodeDeploy agent logs on your host and make sure the agent is running and can connect to the CodeDeploy server”서버 코드 배포 도중 위와 같은 에러와 함께 배포에 실패하게 되었다. 이를 살펴보니다음과 같이 CodeDeploy LifeCycle이 시작도 하지 못한 부분을 확인 할 수 있었다 구글링을 통해서도 쉽게 찾아지지 않아 공식문서를 다시 한번 천천히 읽어보았다   빨간박스 부분을 읽는 순간 불현듯 이전 실습 때도 똑같은 옵션으로 깃헙 레포를 연결하여 생성한 애플리케이션이 생각났고 빠르게 애플리케이션 탭으로 가서 해당 애플리케이션을 삭제하니 정상적으로 진행되었다.  같이 학습한 동기 분들 중에서는 같은 방법으로 해결이 안됐다고 하시는 분도 있어 조금 더 면밀히 찾아봐야될 것 같다Pipeline을 통해 생성되는 레포지토리 이름이 중복된 경우 “The overall deployment failed because too many individual instances failed deployment, too few healthy instances are available for deployment, or some instances in your deployment group are experiencing problems”UnknownError를 해결하고 배포를 재시도하는데 또 실패... 다시 한번 이벤트 로그를 확인해보니  다음과 같은 오류가 발생했고 이유는 배포에 사용되는 EC2 인스턴스에 있는 레포지토리 이름과 Pipeline을 통해 생성될 레포지토리 이름이 중복이 문제였다.곧바로 EC2에 연결하여 문제가 되는 레포지토리 이름을 수정해주었더니 바로 해결!ScriptFailed앞서 설명한 오류들은 좀 부끄러운 케이스지만 이번에는 제대로 된(?) 오류코드와 함께 오류가 발생하여 내심 기뻤다..ㅋ “The overall deployment failed because too many individual instances failed deployment, too few healthy instances are available for deployment, or some instances in your deployment group are experiencing problems” 아까도 같은 말이 나왔는데, &quot;배포 그룹의 일부 인스턴스에 문제가 발생하여 전체 배포에 실패했다&quot;라고 한다 무튼 잘 좀 해보라는 뜻어느 LifeCycle에서 문제가 발생했는지도 잘 짚어주는데 start.sh 쉘 스크립트 파일을 살펴봐도 잘못된 부분은 확인할 수 없었고, 이에 EC2 인스턴스에 기록된 로그를 확인해주었다 CodeDeploy-Agent는 파이프라인 실행 때마다 로그를 해당 EC2 instance에 저장한다고 되어있다/opt/codedeploy-agent/deployment-root/deployment-logs 경로에 저장되어 있는 것을 확인할 수 있었다에러 로그를 확인해본 결과 EC2 인스턴스에 설치된 node, npm 버전이 현 시점과 비교해서 많이 낮은 걸 확인할 수 있었다 (금일 기준 node lts 버전은 v16.14.0)node 및 npm 버전을 최신화해준 후 배포 재시도를 해보았다드디어 해결… 에러 로그 확인도 잘할 수 있어야 프로젝트, 현업 단계에서 당황하지 않고 천천히 해결할 수 있을 것 같다" }, { "title": "DockerBuild &amp; Docker-Compose", "url": "/posts/02-20-TIL-DockerBuild&Compose/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-20 20:30:00 +0900", "snippet": "####" }, { "title": "Docker-CLI", "url": "/posts/02-19-TIL-DockerCLI/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-19 13:30:00 +0900", "snippet": "Docker CLI 공식 문서 참조: 도커 공식 문서✅ 사용법에 대한 내용: Docker CLI, Docker-Compose CLI, API Reference✅ 환경 및 빌드 파일 구성에 대한 내용: Dockerfile, Docker-Compose File  오늘은 Docker CLI를 이용해 Dockerhub로부터 이미지를 가져와 컨테이너를 생성하는 것을 연습해보았다연습한 내용을 작성해보기 전에 간단하게 용어만 다시 짚어보고 시작하자   위와 같이 도커 이미지 CLI는 3가지 정보로 구성되어 있다 Registry Account 앞서 설명했던 대로 이미지를 배포, 공유, 관리하는 공간이다 특별히 다른 내용을 지정하지 않으면 Docker Hub를 기본 레지스트리로 지정한다 Repository Name 레지스트리 내 도커 이미지가 저장되는 공간이다 이미지 이름이 사용되기도 하며, Github의 레포지토리와 유사하다고 볼 수 있다 Tag 같은 이미지도 버전에 따라 그 내용은 상이할 수 있다 주로 버전 정보를 입력하는 데 사용된다 특별히 다른 태그를 지정하지 않는다면 latest 태그를 붙인 이미지를 가져온다 ✅ docker/whalesay:latest를 풀이하자면 이러하다 Dockerhub라는 레지스트리에서 docker라는 유저가 등록한 whalesay 이미지 또는 레포지토리에서 latest 태그를 가진 이미지를 가져온다 docker/whalesay ubuntu 환경에서는 permission denied 에러로 인해 sudo 입력어를 필수로 입력해줘야 한다 docker image pull docker/whalesay:latest 명령어를 통해 원하는 이미지를 가져온다 docker container run [OPTIONS] IMAGE [COMMAND] [ARG...] 이미지를 베이스로 옵션 설정에 맞게 컨테이너를 생성하고 입력된 커맨드에 따라 해당 컨테이너를 실행한다 참고로 image를 pull하지 않고 바로 컨테이너를 실행하게 되면 먼저 로컬에서 이미지를 찾아보고, 없으면 dockerhub로부터 찾아와 가져와서 실행하게 된다 whalesay라는 이름으로 컨테이너를 생성하여 cowsay boo 커맨드에 따라 컨테이너가 실행된 모습Docker 컨테이너에 파일을 복사하기  다른 사람이 제공한 도커 이미지를 받아 사용하는 경우, 원하는 모든 기능이 구성되어 있지 않을 수가 있기에도커 이미지에 파일을 추가하여 도커 이미지를 만드는 방법도 중요하다이번 연습에는 httpd 이미지로 서버를 실행하고 위에 소스코드를 복사해 데이터를 넣어주는 형식으로 진행해보았다 Apache httpd정적인 데이터를 처리해 HTML 이미지를 제공해주는 오픈소스 웹서버 소프트웨어이다 반대로 동적인 데이터를 처리해주는 웹서버는 대표적으로 톰캣(TomCat)이 있다 git clone https://github.com/codestates/pacman-canvas 깃헙에서 연습할 소스코드를 가져와 복사해준다 docker container run --name 컨테이너_이름 -d -p 818:80 httpd 원하는 컨테이너_이름으로 httpd 서버를 실행해주자(이 커맨드로 이미지를 가져와 컨테이너를 생성할 수 있다) -p 로컬호스트와 컨테이너의 포트를 연결해주는 것으로 외부에 포트를 노출시켜 접근할 수 있게 해준다 -d 컨테이너 실행을 백그라운드로 해주는 옵션이다 위 옵션을 생략하면 포어그라운드에서 실행되어 추가 명령어를 입력하려면 새 터미널에서 진행해야한다 ✅ 로컬의 818 포트로 접근하면 서버의 80포트로 접근해 서버가 실행되는 것을 확인할 수 있다 복사한 소스코드 폴더로 이동 후 docker container cp ./ 컨테이너_이름:/usr/local/apache2/htdocs/ 현재 소스코드 폴더를 ~/htdocs/에 복사해준다 복사해줘야하는 경로는 httpd DockerHub에서 안내 사항을 참조 실행 중인 httpd 서버 위에 pacman 소스코드를 복사해 localhost:818에 접근하니 잘 실행되는 것을 확인할 수 있었다느낀점“지금까지 익혀본 단계로는 아직 Docker에게 강력한 이끌림을 느끼지는 못한 것 같다. 내일 3 Tier Architecture를 Docker-Compose로 다뤄보면서 Docker만의 강점을 몸소 느껴볼 예정이다. 추가적으로 Dockerfile로 이미지를 빌드하는 방법도 포스트해 볼 예정이다”" }, { "title": "Docker", "url": "/posts/02-18-TIL-Docker/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-18 21:30:00 +0900", "snippet": "Docker에 대한 간단한 정리 참조 블로그: 초보를 위한 도커 안내서Docker란?Docker란 컨테이너 기반의 오픈 소스 가상화 플랫폼이다 Docker의 강점 Docker는 컨테이너를 이용해 각각의 애플리케이션이 실행되기 위한 환경, 프로그램을 구축한 하나의 공간을 제공할 수 있게 해준다. 즉, 제공되는 애플리케이션을 실행하기 위한 환경을 미리 맞춰서 설정하는 것이 필수조건이 되지 않는다는 것이다. 개발자들 사이, 혹은 서비스 제공 측면에서도 이는 강력한 장점이 된다 그럼 어떤 원리로 작동하는지 간단하게 살펴보도록 하자 컨테이너(Container) 격리된 공간에서 프로세스가 동작하는 기술 ‘흔히 컨테이너를 생각하면 항구에서 짐을 옮기는 데 쓰는 것으로 알고 있을 것이다. 종류, 국적 등 다양한 요소들로 분류하여 물건을 담고 옮기는 데, 이 아이디어를 활용해 소프트웨어에 접목한 것이 컨테이너 기술이라고 볼 수 있다’ 이미지(Image) 컨테이너 실행에 필요한 파일과 설정값들을 포함하고 있는 것으로 애플리케이션 및 구성을 담아놓은 템플릿이다 이미지는 클래스(Class), 컨테이너는 인스턴스(Instance)에 비유해서 생각할 수도 있을 것 같다이미지로부터 필요한 정보를 받아와서 하나의 실행 중인 상태를 만드는 것으로 일단 이해하기로 했다 이미지 출처: https://www.ahnlab.com/kr/site/securityinfo/secunews/secuNewsView.do?seq=30533 레지스트리(Registry) 이미지들을 모아놓은 공간이라고 볼 수 있다. 대표적으로 Docker Hub, Amazon ECR 등이 있다 Docker vs VM가상화 플랫폼인건 알겠는데 그럼 VM(Virtual Machine)과의 차이점은 뭘까? VM(Virtual Machine) 우선 VM이 어떤건지에 간단하게 설명하자면, 호스트 OS(Host OS, 물리적 PC에서 실행되는 OS)위에 Hypervisor 기법을 통해 게스트 OS(Guest OS, 논리적 PC)를 올려 사용하는 느낌으로 볼 수 있다 CPU 성능, 메모리, 네트워크, 리눅스 커널, 파일, 프로세스 모두 호스트와 격리되어 있다는 특징을 가진다 모두 독자적으로 실행되는 구조를 지니는 OS를 새로이 실행하는 느낌이라 컨테이너에 비하면 확실히 무거운 인상을 지닌다 Docker Container 호스트와 확실히 격리되어 있는 VM과는 달리 네트워크, 프로세스, 파일만이 격리되고 CPU, 메모리, 리눅스 커널은 공유한다 OS가 없기에 VM 대비 가벼운 인상을 가진다 네트워크가 호스트와 격리되어 있어 각기 다른 IP 주소를 가지게 된다 컨테이너 방식만의 장점 의존성 충돌 문제를 해결해준다 실행 환경이 철저히 격리되어 있어, 애플리케이션 실행에 필요한 버전 구성으로만 되어 있어 실행이 실패될 우려가 현저히 떨어진다 개발과 배포 환경을 일치시킨다 OS에 상관없이 즉시 애플리케이션을 실행할 수 있어, 유지 보수 및 프로젝트에서도 요긴하게 쓰인다 이 외에도 오케스트레이션, 로드밸런싱 기능을 통해 테스트 환경 및 수평적 확장에도 도움이 된다고 하지만 이 부분은 좀 더 내용을 학습하고 다듬어 포스팅해야겠다. 내일은 실습을 통해 배웠던 Docker CLI에 대해 기술해 볼 예정이다" }, { "title": "Stack &amp; Queue", "url": "/posts/Stack-Queue/", "categories": "Algorithms & CodingTest, Algorithms", "tags": "Stack, Queue", "date": "2022-02-14 12:00:00 +0900", "snippet": "자료구조 데이터 : 문자, 숫자, 소리, 그림, 영상 등 실생활을 구성하고 있는 모든 값 ⇒ 데이터는 분석하고 정리하여 활용해야만 의미를 가질 수 있음⇒ 필요한 데이터에 따라 데이터의 특징을 잘 파악(분석)하여 정리하고, 활용해야 함⇒ 데이터를 체계적으로 정리하여 저장해두는 게, 활용하는 데에 있어 훨씬 유리 자료구조 : 데이터를 효율적으로 다룰 수 있는 방법을 모아둔 것 가장 자주 등장하는 4가지 ⇒ Stack, Queue, Tree, Graph 각각 특정 상황에 놓인 문제를 해결하는 데에 특화되어 있음 ⇒ 많은 자료구조를 알아두어야 다양한 상황에 대처하여 해결할 수 있다 Stack데이터를 순서대로 쌓는 구조 입력과 출력이 하나의 방향으로 이루어지는 제한적 접근⇒ 가장 먼저 들어간 데이터가 가장 나중에 나올 수 있음 위의 자료구조의 정책: LIFO(Last In First Out) / FILO (First In Last Out) 그림 출처 : https://velog.io/@jiwon22/20210414 실사용 예제 : 브라우저의 뒤로 가기, 앞으로 가기 기능1. 새로운 페이지로 접속할 때, 현재 페이지를 Prev Stack에 보관한다2. 뒤로 가기 버튼을 눌러 이전 페이지로 돌아갈 때에는, 현재 페이지를 Next Stack에 보관하고, **Prev Stack에 가장 나중에 보관된 페이지**를 현재 페이지로 가져온다3. 앞으로 가기 버튼을 눌러 앞서 방문한 페이지로 이동할 때에는, **Next Stack의 가장 나중에 보관된 페이지**를 가져온다4. 마지막으로 현재 페이지를 Prev Stack에 보관한다Queue데이터가 입력된 순서대로 처리될 때 주로 사용 Stack과는 정반대되는 개념 FIFO (First In First Out) / LILO (Last In Last Out) ⇒ 가장 먼저 들어간 데이터가 먼저 나오게되는 데이터 구조 ex)프린터 인쇄 순서, 톨게이트 실사용 예제 : 프린터1. 문서를 작성하고 출력 버튼을 누르면 해당 문서는 인쇄 작업[임시 기억 장치의] Queue에 들어감2. 프린터는 인쇄 작업 Queue에 들어온 문서를 순서대로 인쇄// (출력 버튼) - (임시 기억 장치의) Queue에 하나씩 들어옴 - Queue에 들어온 문서 순서대로 인쇄// 아래의 buffer 개념을 접목하여 다시 정리하면- 일반적으로 프린터는 속도가 느림- CPU는 프린터와 비교하여, 데이터 처리 속도가 빠름- **CPU는 빠른 속도로 인쇄에 필요한 데이터를 만든 다음, 인쇄 작업 Queue에 저장하고 다른 작업 수행**- **프린터는 인쇄 작업 Queue에서 데이터를 받아 일정한 속도로 인쇄** =&amp;gt; 동영상 스트리밍에서 버퍼링 발생하는 이유도 위와 같음 위 예시처럼 컴퓨터 장치들 사이에서 데이터를 주고 받을 때, 각 장치 사이에 존재하는 속도의 차이나 시간 차이를 극복하기 위해 임시 기억 장치의 자료구조로 Queue를 사용 ⇒ 이를 통틀어 버퍼(Buffer)라고 부름 버퍼링(Buffering) 대부분의 컴퓨터 장치에서 발생하는 이벤트는 파동 그래프와 같이 불규칙적 이에 비해 CPU와 같이 이벤트를 처리하는 장치는 일정한 처리 속도를 가짐 불규칙적으로 발생한 이벤트를 규칙적으로 처리하기 위해 버퍼(Buffer)를 사용 " }, { "title": "EventLoop", "url": "/posts/02-12-TIL-EventLoop/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-12 18:00:00 +0900", "snippet": "JavaScript는 어떻게 동작하는가JavsScript는 싱글 쓰레드 언어이지만 작동하는 방식에 따라 그렇지 않을 수도 있다이에 대해 잘 정리해서 기록해보자 싱글 쓰레드가 무엇인지에 대해서는 전날의 TIL에 기록되어 있다Event Loop Event Loop를 공부하려면 꼭 이 영상을 참조하라고 추천받는다Event Loop 작동 방식을 직접 확인해보려면 여기서 연습해보자Worker Pool가비지 컬렉션" }, { "title": "컴퓨터공학", "url": "/posts/02-11-TIL-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-11 23:00:00 +0900", "snippet": "컴퓨터공학 기본개념 정리프로그램, 프로세스 https://velog.io/@gparkkii/ProgramProcessThread 참조작업관리자를 켜면 응용프로그램, 프로세스라는 단어를 자주 접해본 적 있을 것이다. 그럼 이 용어들이 뜻하는 바는 무엇일까? 프로그램(Program) 컴퓨터에서 어떤 작업을 위해 실행할 수 있는 ‘정적’인 상태의 파일을 뜻한다(파일 시스템에 존재하는 실행 파일) 프로세스(Process) 프로그램이 실행되고 있는 상태. 즉, ‘동적’인 상태의 컴퓨터 프로그램을 뜻한다즉, 프로그램은 운영체제 위에서 어떠한 작업을 처리하기 위해 존재하는 파일이며, 여기에 메모리 등의 필요한 자원을 할당해서 실행하게 되면 프로세스가 된다 하드웨어 → OS → 프로그램 순으로 명령이 전달되면 정적인 상태의 프로그램이 동적인 상태의 프로세스로 전환된다그 프로세스 안에 수행되는 코드 하나의 흐름을 쓰레드라 한다. 쓰레드에 대한 내용은 하단에서 더 자세히 다루도록 하자 프로세스가 할당받는 자원 CPU 시간, 운영되기 필요한 주소 공간, Code·Data·Stack·Heap의 구조로 되어 있는 독립된 메모리 영역 프로세스의 특징 Code·Data·Stack·Heap의 구조로 되어 있는 독립된 메모리 영역을 할당받는다 각 프로세스는 별도의 주소 공간, 독자적인 메모리 공간을 갖기에 서로 메모리를 공유할 수 없다 즉, 다른 프로세스의 변수나 자료구조에 접근할 수 없다다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)를 사용해야한다 프로세스를 공장에 비유하면 스레드는 작업 인부로 비유할 수 있다운영체제 운영체제란? 하드웨어와 소프트웨어, 사용자를 매개해주는 프로그램 프로그램들이 유용하게 작업을 할 수 있는 환경을 제공해준다즉, 운영체제는 응용 프로그램이 하드웨어에게 일을 시킬 수 있도록 도와준다 운영체제의 기능 시스템 자원 관리 프로세스 관리, 메모리 관리, I/O(입출력) 관리 응용 프로그램 관리 응용 프로그램이 실행되고, 시스템 자원을 사용할 수 있도록 권한과 사용자를 관리 모든 응용 프로그램이 시스템의 자원을 마음대로 사용하게 되면, 해커에 의한 공격에 무방비해진다 하드웨어부터 시작해서 각각의 층을 올라가며 명령이 전달된다고 볼 수 있다쓰레드(Thread) 쓰레드란? 프로세스가 할당 받은 자원을 이용하는 실행 단위이자, 프로세스의 특정한 수행 경로이자 프로세스 내에서 실행되는 여러 흐름의 단위하나의 쓰레드는 코드가 실행되는 하나의 흐름 싱글 쓰레드(Single Thread) 하나의 프로세스에 하나의 쓰레드로 작업을 직렬 처리하는 방식 멀티 쓰레드(Multi Thread) 하나의 프로세스에 여러 개의 쓰레드로 작업을 병렬 처리하는 방식 쓰레드의 특징 각 쓰레드는 독자적인 스택(Stack) 메모리를 갖는다 스택만 할당받고 Code, Data, Heap 영역은 공유한다각 쓰레드는 별도의 레지스터와 스택을 갖지만, 힙 메모리는 서로 읽고 쓸 수 있다 쓰레드는 메모리를 공유하기 때문에 동기화, 데드락 등의 문제가 발생할 수 있다 이미지 출처: https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=bycho211&amp;amp;logNo=220994380643 JavaScript는 Event Loop 기반의 Single Thread 및 Worker Pool 형태의 Mulit Thread로 사용할 수 있다한다이에 대해서도 나중에 기록해두자 " }, { "title": "비동기 복습", "url": "/posts/02-10-TIL-%EB%B9%84%EB%8F%99%EA%B8%B0/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-10 23:00:00 +0900", "snippet": "비동기(Asynchronous)동기 vs 비동기이미지 출처: https://blog.metafor.kr/164 동기(Synchronous) 순서대로 진행되는 여러 작업을 수행하게 될 때, 앞의 작업이 종료되고 나서야 다음 작업이 이어지게 되게끔 동작하는 방식 비동기(Asynchronous) 수행되어야 할 여러 작업들이 동시에 진행되게끔 동작하는 방식 그럼 비동기로 요청하는 것은 똑같은 양의 작업을 수행하는 데 필요한 시간을 줄일 수 있는 건 알겠는데, 특정 작업을 진행하기 위해서 다른 작업의 결과물이 필수요소인 경우에는 어떻게 해야할까? 이렇듯, 비동기로 작업을 진행하는 동안 순서를 제어해주는 데 사용되는 방법들에는 Callback, Promise, Async/Await 이 대표적이다Callback함수가 인자로 다른 함수를 받아 실행되는 것을 뜻한다const someFunction = (callback) =&amp;gt; { console.log(&#39;안녕&#39;); callback()}someFunction(() =&amp;gt; { console.log(&#39;하세요&#39;);}) /* 안녕 * 하세요 *//* 처음 선언된 함수가 호출될 때, &#39;안녕&#39;을 출력하게 되고, * 그런 다음 callback으로 전달된 무명함수가 실행되면서 &#39;하세요&#39;를 출력한다 * 이렇듯 다른 함수를 인자로 받아 그 순서를 제어해주는 것이 Callback 함수이다 */PromisePromise란 JavaScript 비동기 처리에 사용되는 객체를 뜻하며, 주로 AJAX 요청을 위한 기반으로 사용된다 Promise 3가지 상태 Pending 비동기 처리의 결과를 기다리고 있는 상태 Fullfilled 비동기 처리가 정상적으로 완료되었고, 그 결과값을 갖고 있는 상태 Rejected 비동기 처리가 비정상적으로 끝난 상태 const promiseFunction = new Promise((resolve, reject) =&amp;gt; { // 내부에서 reject되는 경우와 resolve되는 경우를 다뤄준다})// Promise 객체는 then()을 통해 체이닝되는 형식으로 순서를 제어하여 데이터를 가공해준다promiseFunction() .then((data) =&amp;gt; console.log(data)) // fullfilled된 상태의 결과값(resolve)이 data에 담겨 전달된다 .catch((err) =&amp;gt; console.error(err)) // rejected 상태의 결과값(reject)이 err에 담겨 전달된다async/awaitES8에서 지원하는 함수로 더 간결하고 직관적으로 작성이 가능해 Promise 및 Callback Hell의 경우를 해소시켜줄 수 있다 Callback과 Promise의 경우는 에러 핸들링을 위한 기능이 제공되나async/await은 자체적인 기능이 없어 try/catch로 에러를 핸들링할 수 있다const asyncFunction = async () =&amp;gt; { // async await을 붙여서 사용함으로써 비동기 처리를 할 수 있게되고, // 동기적으로 처리하는 것과 같이 코드 가독성이 깔끔해지는 장점을 갖는다 try { const someResult = await anotherFunction() console.log(someResult) console.log(&#39;정상 작동!&#39;) /* [anotherFunction의 결과값] * 정상 작동! */ } catch(err) { console.error(err) } // try, catch로 예외처리하여 에러 핸들링을 할 수도 있다}더 알아볼 내용 Promise와 Async/await의 차이점 Promise는 테스트 케이스를 통과 못하지만, async/await은 통과하는 경우가 있었다 (물론 구현되는 내용에는 아무런 차이는 없었다) 코드 가독성이나 에러 핸들링과 같이 코드 상으로 확인할 수 있는 부분 외적으로, 눈에 보이지 않는 추가적인 차이점이 있는지 찾아봐야겠다 " }, { "title": "OAuth를 통한 소셜 로그인", "url": "/posts/02-09-TIL-OAuth/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-09 20:00:00 +0900", "snippet": "OAuth 인증인증(Authentication) vs 인가(Authorization) 인증 : 사용자가 유효한지 판단 (자격 증명) ex) JWT 인가 : 어떤 권한을 획득할 수 있는지 결정 ex) OAuthGithub OAuth 플로우 Github OAuth guide OAuth란? 보안된 리소스에 액세스하기 위해 클라이언트에게 권한을 제공(Authorization)하는 프로세스를 단순화하는 프로토콜 중 한 방법 네이버, 카카오, 구글 등 다양한 서비스가 존재하는 데, 현재 제공하려는 서비스에서 이와 같이 다른 서비스의 회원 정보를 안전하게 사용하기 위한 방법이라고 볼 수 있다 스프린트 진행은 Github을 기준으로 작성되었습니다 우선, Github의 Developer settings에서 OAuth 서비스를 이용하기 위해 애플리케이션 등록을 해준다Client로 사용할 주소(Homepage) 및 AuthorizationCode를 받은 후 Redirect할 주소(callback) 등의 정보로 등록해준다등록을 마치게 되면 위 그림과 같이 Client ID, Client Secret을 발급받을 수 있다 Authorization Code를 받아오기 위해 Github에 요청한다 (Request a user’s GitHub identity) // 클라이언트 const axios = require(&#39;axios&#39;); // 1. URI에 직접 쿼리를 작성하는 방법 -&amp;gt; Promise 혹은 Async / await 방법으로 요청한 데이터를 확인할 수 있다 axios.get(&#39;https://github.com/login/oauth?client_id=[ClientId]&#39;, {}, { headers: { accept: &#39;application/json&#39; // application/vnd.github+json - 공식문서에서는 이 타입을 추천한다고 나와있다 } // header 설정으로 타입에 대한 협상을 하지않으면 응답의 데이터가 문자열 형태로 오는 것으로 기본값이 설정되어 있다 }) // 2. params에 필요한 파라미터를 넣어 전달하는 방법 axios.get(&#39;https://github.com/login/oauth&#39;, { client_id: [ClientId] }, { headers: { accept: &#39;application/json&#39; } }) 위 코드처럼 github.com/login/oauth에 client_id를 넣어 요청하면 AccessToken을 받기 위해 필요한 code 정보를 받아올 수 있다 OAuth 등록 시 작성했던 Callback URL로 Redirect되면서 Code를 가져오는 것을 확인할 수 있다 const url = new URL(window.location.href) const authorizationCode = url.searchParams.get(&#39;code&#39;) // URL로부터 code 정보를 가져오자 받아온 Authorization Code를 이용해 Github에 AccessToken 발급을 요청한다 이때, 요청을 위해 꼭 필요한 파라미터는 client_id, client_secret, code 세 종류이다 // 서버 axios .post(&#39;https://github.com/login/oauth/access_token&#39;, { client_id: clientID, client_secret: clientSecret, // 보안이 필요한 정보니 꼭 환경변수로 설정하여 감춰주자 code: req.body.authorizationCode }, { headers: { &quot;Accept&quot;: &quot;application/json&quot; // 응답으로 오는 토큰 정보를 좀 더 쉽게 다루기 위해 데이터 타입을 정해주자 // &quot;application/vnd.github+json&quot; 옵션을 추천한다고 되어있는 데 추후에 알아보자 } }) 발급받은 토큰을 클라이언트로 전달해주고 이 후 클라이언트는 원하는 정보를 가져오기 위해 리소스 서버에 요청을 보낼 때 토큰을 헤더에 넣어 보내준다 이 부분은 앞서 토큰 기반 인증에서도 다룬 내용이라 자세한 코드 내용은 생략했습니다 Content-Type vs Accept Content-Type 클라이언트에서 서버로 요청을 보낸다 가정했을 때, 요청에 보내주는 데이터 타입을 결정해주는 헤더 ```jsx axios.post([URL], { name: &quot;SsankQ&quot; }, { &quot;Content-Type&quot;: &quot;application/json&quot; }) ``` Accept 클라이언트에서 서버로 요청을 보내고 그에 대한 응답을 받는 경우, 받을 데이터의 타입을 정해주는 헤더 ```jsx axios.get([URL], { headers: { &quot;Accept&quot;: &quot;application/json&quot; } }) ``` OAuth Flow이미지 출처: 코드스테이츠이해를 하기 위한 필사적으로 끄적여본 낙서들…" }, { "title": "토큰기반인증", "url": "/posts/02-08-TIL-%ED%86%A0%ED%81%B0%EA%B8%B0%EB%B0%98%EC%9D%B8%EC%A6%9D/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-08 19:00:00 +0900", "snippet": "JWT를 이용한 토큰 기반 인증JWT JWT란? JsonWebToken, 웹 또는 모바일에서의 유저 인증을 위해 만들어진 암호화된 토큰으로 클라이언트에 저장된다 AccessToken 보호된 정보들에 접근할 수 있는 권한을 부여하는 데 사용 RefreshToken AccessToken보다 비교적 긴 유효기간을 갖고, 만료된 토큰을 새로 재발급하는 데 사용 JWT 구성 정보 header 어떤 타입의 토큰을 다루며, 어떤 알고리즘으로 암호화하는 지에 대한 정보를 뜻한다 payload 기본적으로 유저의 정보 및 기타 필요한 정보를 뜻한다 signature Header, Payload를 base64 인코딩한 값과 salt한 값의 조합으로 암호화된 값 jsonwebtoken 모듈 https://github.com/auth0/node-jsonwebtoken 참조 jsonwebtoken에서 사용하는 method들은 Async, Sync한 방법으로 각각 사용할 수 있다 Asynchronous If a callback is supplied, the callback is called with the err or the JWT. Synchronous Returns the JsonWebToken as string jwt.sign(payload, secretOrPrivateKey, [options, callback]) 인자로 주어진 payload와 key를 이용해 jwt 토큰을 생성해준다 const jwt = require(&#39;jsonwebtoken&#39;);// Synchrounous - callback을 다루지 않으며 주어진 정보로 바로 토큰을 생성해준다const token = jwt.sign({ foo: &#39;bar&#39; }, &#39;shhhhh&#39;); //// Asynchrounous - callback을 이용해 (err, token) 인자를 기본으로 받아 추가적인 작업을 진행한다jwt.sign(payload, key, (err, token) =&amp;gt; { // token은 생성된 token을 의미 if(err) ~~ else ~~}); jwt.verify(token, secretOrPublicKey, [options, callback]) 암호화된 token을 key를 이용하여 해독, 검증해준다 const jwt = require(&#39;jsonwebtoken&#39;);// Syncconst verifiedData = jwt.verify(token, key)console.log(verifiedData) // 해독된 데이터 출력// Asyncjwt.verify(token, key, (err, decoded) =&amp;gt; { // decoded : 해독된 데이터 if(err) ~ else ~ }) 토큰 기반 인증 절차 예시코드 및 전체적인 흐름은 Sprint 과제 Repository를 기반으로 작성jsonwebtoken, axios, express 등의 모듈 사용 같이 진행한 페어와 흐름을 얘기하다가 그려본건데 내가 봐도 엉망이다 클라이언트에서 username(id), password 정보를 입력 후 Login 버튼으로 서버에 POST 요청을 보낸다 이때 HTTP 통신을 위해 axios 모듈을 사용한다 const axios = require(&#39;axios&#39;);// axios.post(url[, data[, config]]) axios .post(URL, { username: username, // data 부분에 입력한 내용은 req.body로 전송된다 password: password }, { &quot;Content-Type&quot;: &quot;application/json&quot;, // body를 보내줘야하니 그에 맞는 데이터 타입을 헤더에 추가해야 한다 withCredentials: true // post 요청을 통해 토큰을 쿠키로 전송받게 되니, 꼭! 서버의 cors 설정과 같이 해주자 }) .then((res) =&amp;gt; console.log(res)) // 서버 측에 정상적으로 요청하여 그에 대한 응답을 반환 전달받은 username(id), password를 바탕으로 이에 부합하는 데이터가 존재하는 지 DB에 쿼리를 보내 조회해본다 MVC 패턴을 위해 mysql, Sequelize를 사용하고 있으니 이들이 바탕이 되게 코드를 작성했다 const { Users } = require(&#39;[relative path]/models&#39;); module.exports = async (req, res) =&amp;gt; { const userInfo = await Users.findOne({ where: { username: req.body.username, password: req.body:password } }) console.log(userInfo) /* Users { dataValues { // } } */} DB에 사용자를 조회하여 검증된 사용자라면 Access 및 RefreshToken을 발행해서 클라이언트에 보내준다 const accessToken = jwt.sign(userInfo, access_key, { options })const refreshToken = jwt.sign(userInfo, refresh_key, { options }) // 이때 refresh 시간을 좀더 길게 잡아준다res .cookie(&quot;refreshToken&quot;, refreshToken, { // refresh 토큰은 쿠키에, // 쿠키 옵션들 }) .json({ &quot;accessToken&quot;: accessToken, // access 토큰은 body에 넣어 보내준다 &quot;message&quot;: &quot;ok&quot; }) 토큰을 발행받은 클라이언트는 토큰을 제시하면서 서버에 요청을 보내 원하는 정보, 서비스를 제공받을 수 있다 반드시, 요청을 보낼 때 토큰을 얹어서 요청해야한다 Postman 요청 시, Authorization 탭에 Barer Token을 선택하여 발급 받은 Token을 넣어서 요청을 진행한다. Client 상에서 요청을 보낼 때에는 headers.authorization 형태로 넣어서 요청을 보낸다 axios .get(URL, { headers: { authorization: `Bearer ${accessToken}` // 이번 스프린트에서는 Bearer authentication을 사용 } }) AccessToken을 이용해 필요한 정보를 DB로부터 받아와 서버에서 클라이언트로 전송해준 후 클라이언트에서 렌더링해준다 const verifiedData = jwt.verify(accessToken, access_key)console.log(verifiedData) // 해독된 정보가 표시된다const { username } = verifiedData; // 유저 정보를 가져오기 위해 username(id)를 가져와서const userInfo = await Users.findOne({ where: { username: username } // DB에서 조회하여 데이터를 가져온다})// 응답 메세지에 적절하게 userInfo를 담아 전송해준다 혹여나 AccessToken이 만료되는 경우 필요한 정보를 받아오지 못하게 되니 RefreshToken을 통해 새로 발급받는다 // Refresh 토큰을 통해 새로 Access 토큰을 발급받기 위해 서버에 요청을 보낸다req.cookies.refreshToken // 정상적으로 쿠키에 담겨 있어야 한다// token이 유효하지 않을 수도 있으니, async한 방법으로 err도 처리해주자jwt.verify(refreshToken, refresh_key, async (err, decoded) =&amp;gt; { if(err) ~ // 적절한 에러 메시지 전달 else { // decoded에 해독된 정보가 있다 // 이를 이용해 DB에 다시금 사용자 정보를 조회 후 가져온다 const userInfo = await Users.findOne({ where: { username: decoded.username } }) // userInfo로부터 정보를 받고 여기서 필요한 정보를 추려서 다시금 accessToken 생성해준다 const newAccessToken = jwt.sign(userData, access_key, { options }) // 다시 클라이언트에 새로운 토큰을 전달해줌으로써 클라이언트는 유효한 accessToken을 갖게 된다 res.json({ &quot;accessToken&quot;: newAccessToken, &quot;userInfo&quot;: userData }) }}) " }, { "title": "인증/보안", "url": "/posts/02-07-TIL-%EC%9D%B8%EC%A6%9D%EB%B3%B4%EC%95%88/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-08 00:00:00 +0900", "snippet": "인증 보안How to kill specific PORT 과제, 학습 진행 중에 자꾸 서버를 열어놓은 상태로 종료하는 경우가 있으니.. 잘 체크해야겠다lsof -i:8080: 8080포트를 사용 중인 프로세스 리스트를 출력kill $(lsof -t -i:8080): 8080포트를 사용 준인 프로세스를 종료Axios vs Fetch axios axios는 Node.js와 브라우저를 위한 HTTP 통신 라이브러리 비동기로 HTTP 통신을 가능하게 해주며 promise 기반으로 되어있어 데이터 다루기가 쉽다 장점 response timeout 처리 방법 존재 브라우저 호환성이 뛰어나다 자동으로 json 데이터로 변환 단점 별도로 모듈 설치를 해줘야하기에 fetch에 비하면 사용하기 귀찮..음? fetch ES6부터 JavaScript 내장 라이브러리(Built-in APIs)로써 사용되고 있다 axios와 마찬가지로 promise 기반으로 되어 있다 장점 별도로 모듈을 설치하여 import할 필요가 없다 내장 라이브러리기에 업데이트에 따른 에러 방지 가능 단점 IE 특정 버전과 같이 fetch가 지원되지 않기도 한다(호환성이 떨어짐) axios에 비해 기능이 부족하다 json 데이터 핸들링을 위해 추가 절차가 필요하다 withCredentials? Credentials 쿠키, 인증헤더, TLS 증명서를 뜻한다 Credentials를 포함하는 CORS 요청은 Client, Server 모두 Credentials를 사용하겠다는 속성을 설정해줘야 통신이 가능하다 Express cors() 미들웨어를 사용한 CORS 설정 예시 (Server) credentials Configures the Access-Control-Allow-Credentials CORS header. app.use(cors({ origin: &#39;https://localhost&#39;, methods: [&#39;GET&#39;, &#39;POST&#39;, &#39;OPTIONS&#39;], credentials: true // 기본값을 false로 설정되어 있다 })); 인증 정보를 포함한 통신시 Allow-Origin을 모두 허용하는 경우 지원하지 않으므로 Origin 설정 필수 Axios 요청을 통해 withCredentials 설정 예시 (Client) axios.post(url[, data[, config]]) axios.post(&#39;https://localhost:4000/users/login&#39;, { userId: this.state.username, password: this.state.password}, { &quot;Content-Type&quot;: &quot;application/json&quot;, withCredentials: true,}) // get 요청의 경우 data(body)는 생략하므로 url[, config] 형태로 요청 HTTPS 인증서는 무엇을 보장할까 ? 브라우저에서 접속한 서버가 “의도한” 서버임을 보장 = 전자서명 브라우저와 서버가 통신할 때 암호화할 수 있도록 서버의 공개키 제공 HTTPS? 기밀성 다른 사용자들이 전달되는 메시지를 가로챌 수 없다 무결성 다른 사용자들이 전달되는 메시지를 조작할 수 없다 HTTPS는 어떻게 동작하는가? 공개키로 사용자 세션키를 서버에게만 안전히 전달하고 그를 바탕으로 대칭키 방식으로 암호화된 채널로 소통한다 암호화 대칭키 암호화 하나의 키로 암-복호화 진행 비대칭키 암호화 개인키로 암호, 공개키로 복호 = 전자서명 공개키로 암호, 개인키로 복호 = 암호화 해시 시드 + 본문의 해시값이 같은지 확인 일방향 해시함수 암호화는 되나, 복호화가 되지 않음 =&amp;gt; 해시된 값으로 판별 " }, { "title": "React State &amp; props", "url": "/posts/State-Props/", "categories": "React, React Intro", "tags": "React", "date": "2022-02-04 16:00:00 +0900", "snippet": "React State &amp;amp; PropsAchievement Goals state, props의 개념에 대해서 이해하고, 실제 프로젝트에 바르게 적용할 수 있다 React Function Component에서 state hook을 이용하여 state를 정의 및 변경할 수 있다 React Component에 props를 전달할 수 있다 이벤트 핸들러 함수를 만들고 React에 이용할 수 있다 실제 웹 애플리케이션의 컴포넌트를 보고 어떤 데이터가 state고 props에 적합한지 판단할수 있다 실제 웹 애플리케이션 개발 시 적합한 state와 props의 위치를 스스로 정할 수 있다 React의 단방향 데이터 흐름(One-way data flow)에 대해 자신의 언어로 설명할 수 있다 props란 컴포넌트의 속성을 의미 변하지 않는 외부로부터 전달받은 값 ⇒ 웹 앱에서 해당 컴포넌트가 가진 속성 부모 컴포넌트(상위)로부터 전달 받은 값 객체 형태 : 어떤 타입의 값도 전달할 수 있음 읽기 전용 : 함부로 변경되어서는 안되기 때문 만약 수정가능하게 되면 하위 컴포넌트에서 수정된 props가 상위에 영향을 끼치게 되고,이는 단방향, 하향식 데이터 흐름 원칙에 위배됨How to use props 3단계 하위 컴포넌트에 전달하고자 하는 값과 속성을 정의한다 props를 이용하여 정의된 값과 속성을 전달한다 전달받은 props를 렌더링한다1. 각 컴포넌트를 선언, 작성 function Parent() { return ( &amp;lt;div className=&quot;parent&quot;&amp;gt; &amp;lt;h1&amp;gt;I&#39;m the parent&amp;lt;/h1&amp;gt; &amp;lt;Child /&amp;gt; &amp;lt;/div&amp;gt; ); } function Child() { return ( &amp;lt;div className=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt; ); };2. 전달하고자 하는 속성 및 값 할당 &amp;lt;Child attribute={value} /&amp;gt;ex) &amp;lt;Child text={&quot;I&#39;m the eldest child&quot;} /&amp;gt;3. 전달한 문자열을 Child 컴포넌트에서 받아오게 한다// 함수에 인자를 전달하듯, 컴포넌트에 props 전달function Child(props) { return ( &amp;lt;div className=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt; );};4. props 렌더링 // JSX 문법 사용function Child(props) { return ( &amp;lt;div className=&quot;child&quot;&amp;gt; **&amp;lt;p&amp;gt;{props.text}&amp;lt;/p&amp;gt;** &amp;lt;/div&amp;gt; );}// props는 객체 {attribute(=key): value} =&amp;gt; props.text--props.children: props를 전달하는 또 다른 방법function Parent() { return ( &amp;lt;div className=&quot;parent&quot;&amp;gt; &amp;lt;h1&amp;gt;I&#39;m the parent&amp;lt;/h1&amp;gt; **&amp;lt;Child&amp;gt;I&#39;m the eldest child&amp;lt;/Child&amp;gt;** &amp;lt;/div&amp;gt; );};function Child(props) { return ( &amp;lt;div className=&quot;child&quot;&amp;gt; **&amp;lt;p&amp;gt;{props.children}&amp;lt;/p&amp;gt;** &amp;lt;/div&amp;gt; );};// 여닫는 태그 사이에 value를 넣어 전달하는 방법도 가능// 이 경우 props.children을 이용해 value에 접근State컴포넌트 내에서 변할 수 있는 값state hook, useState useState 사용법1. **React로부터 useState 불러오기**import { useState } from &quot;react&quot;;2. **useState를 컴포넌트 안에서 호출** =&amp;gt; state라는 변수를 선언하는 것과 같으며, 변수의 이름은 아무렇게 지어도 상관없음 (*일반적인 변수는 함수가 끝날 때 사라지지만, state는 React에 의해 함수가 끝나도 안사라짐)function CheckboxExample() { const [isChecked, setIsChecked] = useState(false);// 새로운 state 변수를 선언/* useState를 호출하면 배열을 반환 =&amp;gt; r **배열의 0번째 요소는 현재 state 변수, 1번째 요소는 이 변수를 갱신할 수 있는 함수 useState의 인자로 넘겨주는 값은 state의 초기값 */ const [state 저장 변수, state 갱신 함수] = useState(상태 초기 값);**// isChecked : state를 저장하는 변수// setIsChecked : state **isChecked**를 변경하는 함수// useState : state hook// false : state 초기값 이후 삼항연산자로 true false에 따라 결과 여부 &amp;lt;span&amp;gt;{isCheckd ? &quot;Checked!!&quot; : &quot;Unchecked&quot;}&amp;lt;/span&amp;gt;state 갱신하기 state를 갱신하려면 state 변수를 갱신할 수 있는 함수를 호출 이벤트 핸들러function CheckboxExample () { const [isChecked, setIsChecked] = useState(false); const handleChecked = (event) =&amp;gt; { setIsChecked(event.target.checked); }; return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;input type=&quot;checkbox&quot; checked={isChecked} onChange={handleChecked} /&amp;gt; &amp;lt;span&amp;gt;{isChecked ? &quot;Checked!!&quot; : &quot;Unchecked&quot;}&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; );} 주의점 React 컴포넌트는 state가 변경되면 새롭게 호출되고, 리렌더링됨 React state는 상태 변경 함수 호출로 변경해야 함 (강제 변경 시도는 절대 X) ⇒ 그렇지 않으면 리렌더링이 되지않거나, state가 제대로 변경되지 않음 이벤트 처리 React에서 이벤트는 소문자 대신 카멜 케이스를 사용 JSX를 사용하여 문자열이 아닌 함수로 이벤트 처리 함수(Event handler)를 전달// HTML에서의 이벤트 처리 방식&amp;lt;button onclick=&quot;handleEvent()&quot;&amp;gt;Event&amp;lt;/button&amp;gt;// React에서의 이벤트 처리 방식&amp;lt;button onClick={handleEvent}&amp;gt;Event&amp;lt;/button&amp;gt; onChangefunction NameForm() { const [name, setName] = useState(&#39;&#39;); const handleChange = (e) =&amp;gt; { setName(e.target.value); } return ( &amp;lt;div&amp;gt; &amp;lt;input type=&quot;text&quot; value={name} onChange={handleChange}&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;h1&amp;gt;{name}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; )};/* 1. onChange 이벤트가 발생하면 e.target.value를 통해 이벤트 객체에 담겨있는 input값을 읽음 (**onChange는 input의 텍스트가 바뀔때 마다 발생하는 이벤트**) * 2. 이벤트 발생하면 handleChange 함수 작동 * 3. 이벤트 객체에 담긴 input값을 setState를 통해 새로운 state로 갱신 */ onClickfunction NameForm() { const [name, setName] = useState(&#39;&#39;); const handleChange = (e) =&amp;gt; { setName(e.target.value); } return ( &amp;lt;div&amp;gt; &amp;lt;input type=&quot;text&quot; value={name} onChange={handleChange}&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;button onClick={alert(name)}&amp;gt;Button&amp;lt;/button&amp;gt; &amp;lt;h1&amp;gt;name&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; );};/* 1. button을 클릭하면 onClick 이벤트 발생 =&amp;gt; alert 함수 호출 * 2. 함수 자체가 아닌 함수의 값이 호출됨 : alert**(name) ***** 함수에 리턴값이 존재하지 않기에 undefined 반환 =&amp;gt; onClick에 적용 =&amp;gt; **클릭 시 변화 x** ***/ onClick - 함수 정의하기, 함수 자체 전달하기// 1. 함수 정의하기 return ( &amp;lt;div&amp;gt; &amp;lt;button onClick={ () =&amp;gt; alert(name)}&amp;gt;Button&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); };// 2. 함수 자체 전달하기 const handleClick = () =&amp;gt; { alert(name); }; return ( &amp;lt;div&amp;gt; &amp;lt;button onClick={handleClick}&amp;gt;Button&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );" }, { "title": "세션 &amp; HTTPS", "url": "/posts/02-03-TIL-%EC%84%B8%EC%85%98-HTTPS/", "categories": "TIL, 2022-02", "tags": "TIL", "date": "2022-02-03 15:00:00 +0900", "snippet": "인증 보안 복습세션 인증 방식 클라이언트로부터 서버에 요청 전송을 하면, DB(Session Store)에 정보가 저장되면서 session_id가 생성됨 생성된 session_id를 Set-Cookie 헤더로 전송하여 클라이언트에 정보를 저장하게 만듦 session_id 정보가 서버에 보관중이기에 다시금 요청을 보내면, 이를 통해 인증하게 됨 쿠키 vs 세션 인증 방식   설명 접속 상태 저장 경로 장점 단점 Cookie HTTP의 무상태성을 보완해주는 도구 클라이언트 서버에 부담을 덜어줌 쿠키 그 자체는 인증이 아님 Session 접속 상태를 서버가 가짐(Stateful) 접속 상태와 권한 부여를 위해 세션 아이디를 쿠키로 전송 서버 신뢰할 수 있는 유저인지 서버에서 추가로 확인 가능 하나의 서버에서만 접속 상태를 가지므로 분산에 불리 세션 로그아웃의 중요성 세션 아이디가 담긴 쿠키가 유출된 상태에서는 해당 쿠키를 이용한 요청이 유출된 쿠키를 이용한 공격인지,정말로 사용자가 요청을 보낸건지 서버는 확인할 방법이 없다 &amp;gt; 즉, 서버에서 세션을 파괴하는 과정이 반드시 필요 로그아웃 방법 2가지 서버 세션 스토어에 있는 세션을 지우고 (.destroy) 클라이언트에서 세션 아이디를 없앤다 서버 세션 스토어에 있는 세션을 지우고 (.destroy) 서버에서 클라이언트가 가진 세션아이디를 빈 문자열, 혹은 랜덤값으로 바꿔버린다 HTTPS와 SSL 인증서 자료 참조 : 생활 코딩 HTTPS란? 쉽게 말하면 HTTP 프로토콜에서 보안 기능을 추가한 것 S : (Over Secure Socket Layer) 보안 기능을 추가하여 제 3자로부터 정보를 보호하고, 기관으로부터 인증 받음으로써 신뢰성을 갖게 된다 SSL(Secure Socket Layer)이란? HTTP와 TCP 계층 사이에 추가된 계층, Secure 정보를 암-복호화하기 위해 대칭키, 비대칭키 사용 대칭키 암-복호화를 위해 사용되는 서버와 클라이언트가 갖는 동일한 키 비대칭키 (알고리즘이 대칭키에 비해 비교적 복잡하며, 부하가 많이 발생) 암-복호화를 위해서 A, B(공개키, 개인키) 사용, A키로 암호화한 정보는 B키로만 복호화 가능 " }, { "title": "React SPA &amp; Router", "url": "/posts/SPA/", "categories": "React, React Intro", "tags": "React", "date": "2022-02-02 19:00:00 +0900", "snippet": "SPA &amp;amp; RouterAchievement Goals SPA(Single-Page Application) 개념을 이해하고 설명할 수 있다 SPA의 장, 단점에 대해 이해하고 설명할 수 있다 와이어프레임을 보고 어느 부분을 컴포넌트로 구분할 지 스스로 정할 수 있다 React에서 npm으로 React Router Dom을 설치하고 이용할 수 있다 React Router Dom을 이용하여 SPA를 구현할 수 있다 라우팅 구조를 짤 수 있어야 하고, 이에 필요한 기초 문법들을 사용할 수 있어야 한다 SPA전통적인 웹사이트 vs SPA 페이지 전환시, 전통적인 웹사이트는 페이지 전체를 불러옴 - ‘깜빡임’ ⇒ 불필요한 트래픽 발생 ⇒ UX 저하를 야기 SPA (Single-Page Application) 서버로부터 완전한 새로운 페이지를 불러오지 않고 페이지 갱신에 필요한 데이터만 받아그 정보를 기준으로 현재의 페이지를 업데이트함으로써 사용자와 소통하는 웹 App or 웹 사이트 SPA의 장점 사용자와의 Interaction에 빠르게 반응 ⇒ 필요한 부분의 데이터만 받아 화면을 업데이트하면 되기에 서버 과부하 문제가 현저하게 줄어듦 ⇒ 요청 받은 데이터만 넘겨주면 되기에 더 나은 유저경험을 제공 ⇒ 전체 페이지를 렌더링할 필요가 없기 때문에 SPA의 단점 첫 화면 로딩시간이 길어짐 SPA의 경우 JavaScript 파일이 크기 때문에 JavaScript 파일을 기다리는 시간으로 인해 로딩 지연 검색 엔진 최적화(SEO)가 좋지 않음 구글이나 네이버같은 검색 엔진은 HTML 파일에 있는 자료를 분석하는 방식으로 *검색 기능 구동,SPA의 경우 HTML 파일은 별다른 자료가 없기 때문에 검색 엔진이 적절히 동작하지 못함 검색 엔진의 작동 방식 검색 로봇이 웹 페이지에 있는 정보를 수집하고 분석해서 그 결과값에 인덱스를 만들어 보관하고 있다가 사용자가 검색어를 입력하면 보관하고 있던 인덱스에서 검색어와 가장 연관성이 높은 웹 페이지들을 순서대로 보여주는 방식으로 작동 RouterRouting : 다른 주소에 따라 다른 뷰를 보여주는 과정 ⇒ “경로에 따라 변경한다” 라는 의미의 라우팅React Router의 주요 컴포넌트 BrowserRouter : 라우터 역할 Switch와 Route : 경로 매칭 역할 Link : 경로 변경 역할import { BrowserRouter, Switch, Route, Link } from &quot;react-router-dom&quot;;/* **import** : 필요한 모듈을 불러오는 역할 React Router 사용 환경 세팅1. react-router 라이브러리 설치 $ npx create-react-app simpleroute // simpleroute 폴더에 React App 설치 $ cd simpleroute $ npm install react-router-dom // react-router 라이브러리 설치2. App.js로 react-router 컴포넌트 꺼내오기 import React from &quot;react&quot;; import { BrowserRouter, Switch, Route, Link } from &quot;react-router-dom&quot;; export default function App() { return ( ... ) }" }, { "title": "클로저", "url": "/posts/Closure/", "categories": "JavaScript, basic", "tags": "JavaScript", "date": "2022-01-29 18:00:00 +0900", "snippet": "ClosureAchievement Goals 클로저 함수의 정의와 특징에 대해 이해할 수 있다 클로저가 갖는 스코프 범위를 이해할 수 있다 클로저를 이용해 유용하게 쓰이는 몇 가지 코딩 패턴을 이해할 수 있다 클로저 함수의 특징 함수를 리턴하는 함수 const adder = x =&amp;gt; y =&amp;gt; x + y; adder(5)(7); // 12 typeof adder(5) // &#39;function&#39; =&amp;gt; return 값이 함수 const adder = function (x) { return function(y) { return x + y; // 분홍색 배경 : 리턴 값이 함수의 형태 } } 리턴하는 함수에 의해 스코프가 구분된다 클로저의 핵심은 스코프를 이용해서, 변수의 접근 범위를 닫는(closure)데에 있다 내부 함수는 외부 함수에 선언된 변수에 접근 가능 const adder = function (x) { // 외부함수의 변수 x return function(y) { // 내부함수의 변수 y return x + y; } }- 외부함수는 y에 접근 불가 =&amp;gt; 바깥 스코프에서는 안쪽 스코프로 접근 불가- 내부함수는 x에 접근 가능 =&amp;gt; 안쪽 스코프는 바깥 스코프에서 선언한 변수에 접근 가능클로저의 활용에 따른 특징 데이터를 보존하는 함수 const adder = function (x) { return function(y) { return x + y; }}const add5 = adder(5); // 클로저를 통해 리턴한 함수가 담겨 있음add5(7) // 12add5(10) // 15// 외부 함수 (adder)의 실행이 끝나더라도, 외부 함수 내 변수(x)를 사용할 수 있다 모듈화 함수의 재사용성을 극대화하여, 함수 하나를 완전히 독립적인 부품 형태로 분리하는 것 클로저를 이용해 내부 함수를 하나만 리턴하는 것에 그치지 않고, 객체에 담아 여러 개의 내부 함수를 리턴하게 만들 수도 있다 const makeCounter = () =&amp;gt; { let value = 0; return { increase: () =&amp;gt; { value = value + 1 }, decrease: () =&amp;gt; { value = value - 1 }, getValue: () =&amp;gt; value }} const counter1 = makeCounter();counter1 // { increase: f, decrease: f, getValue: f } // 함수 여러개를 포함한 객체**makeCounter 함수를 바꾸지 않고, value 변수에 새로운 값을 할당하는 것은 불가 : 스코프 규칙**const counter1 = makeCounter();counter1.increase();counter1.increase();counter1.decrease();counter1.getValue(); // 1const counter2 = makeCounter();counter2.decrease();counter2.decrease();counter2.decrease();counter2.getValue(); // -3// 위의 결과를 통해 makeCounter에 의해 리턴된 객체에서는 각자 독립적으로 선언된 Value 값을 지니고 함수를 진행하게 됨// =&amp;gt; 서로에게 영향을 끼치지 않고, 각각의 값을 보존 HTML에서의 활용도 유용하다const tagMaker = tag - content &amp;gt;&amp;gt; `&amp;lt;${tag}&amp;gt;${content}&amp;lt;/${tag]&amp;gt;`const divMaker = tagMaker(&#39;div&#39;); divMaker(&#39;hello&#39;) // &#39;&amp;lt;div&amp;gt;hello&amp;lt;/div&amp;gt;&#39; divMaker(&#39;codestates&#39;) // &#39;&amp;lt;div&amp;gt;codestates&amp;lt;/div&amp;gt;&#39;const anchorMaker = tagMaker(&#39;a&#39;); anchorMaker(&#39;go&#39;) // &#39;&amp;lt;a&amp;gt;go&amp;lt;/a&amp;gt;&#39;" }, { "title": "스코프", "url": "/posts/Scope/", "categories": "JavaScript, basic", "tags": "JavaScript", "date": "2022-01-29 17:00:00 +0900", "snippet": "Achievement Goals 스코프의 의미와 적용 범위를 이해할 수 있다 스코프의 중요 규칙을 이해할 수 있다 중첩 규칙 block scope와 function scope 전역 스코프와 지역 스코프 전역 변수와 지역 변수 간의 우선 순위 let, const, var의 차이 전역 객체 window의 이해 Scope 변수 접근 규칙에 따른 유효 범위 let username = &#39;kim&#39;;if(username) { let message = `Hello, ${username}!`; console.log(message); // Hello, kim}console.log(message); // Reference error : 중괄호 안에 있는 message 변수를 불러오지 못함/* ! 중괄호(블록) 안에 변수가 선언되었는지, 밖에 선언되었는지가 중요 =&amp;gt; 범위: 스코프 * 바깥쪽 스코프에서 선언된 변수는 안쪽에서 사용가능 * 안쪽 스코프에서 선언된 변수는 바깥쪽에서 사용불가 * 스코프는 중첩이 가능 */가장 바깥쪽 스코프 =&amp;gt; 전역 스코프전역 스코프 외 =&amp;gt; 지역 스코프 지역 변수는 전역 변수보다 더 높은 우선순위를 가짐 ⇒ 쉐도잉 : 동일한 변수 이름으로 인해 바깥쪽 변수가 안쪽 변수에 의해 가려지는 현상 Scope의 종류 화살표 함수를 사용하면 블록 스코프로 취급 function 키워드를 사용하면 함수 스코프 ⇒ 블록 스코프와 함수 스코프는 차이가 있음을 인지할 것! 함수 스코프는 함수의 실행부터 종료까지이고, var 선언은 함수 스코프의 최상단에 선언 선언 키워드 없는 선언은 최고 스코프에 선언 함수 내에서 선언 키워드 없는 선언은 함수의 실행 전까지 선언되지 않은 것으로 취급 선언 키워드 let 블록 단위로 스코프를 구분했을 때, 훨씬 더 예측 가능한 코드를 작성할 수 있으므로 let 키워드의 사용이 권장됨 for(let i = 0; i &amp;lt; 5; i++) { console.log(i); } console.log(&#39;final i:&#39;, i); // Reference error // 블록 스코프 안에서 정의된 변수 i(for문)는 블록 범위를 벗어나는 즉시 접근할 수 없음 var var를 사용하지 않는다해도, 함수 스코프는 let으로 선언된 변수의 접근 범위를 제한함 for(var i = 0; i &amp;lt; 5; i++) { console.log(i); } console.log(&#39;final i:&#39;, i); // 5 // var 키워드는 블록 스코프를 무시하고, 함수 스코프만 따름 (화살표 함수의 블록 스코프 제외) window 객체 (browser only) : var로 선언된 전역변수 및 전역 함수는 window 객체에 속하게 됨 브라우저에는 window라는 객체가 존재. 그러나, 브라우저 창과 관계없이 전역 항목도 담고 있음 var myName = &#39;김코딩&#39;; console.log(window.myName); // 김코딩 function foo() { console.log(&#39;bar&#39;); } console.log(foo === window.foo); // true const 값이 변하지 않는 상수를 정의할 때 쓰는 키워드 let 키워드와 동일하게 블록 스코프를 따름 값의 변경을 최소화하여 보다 안전하게 프로그램 제작 가능⇒ 값을 새로 할당할 일이 없다면 const 키워드의 사용이 권장됨⇒ 값을 재할당하는 경우, TypeError 키워드 비교   let const var 유효 범위 블록 및 함수 스코프 블록 및 함수 스코프 함수 스코프 값 재할당 가능 불가능 가능 재선언 불가능 불가능 가능 변수 선언 시 주의점 전역변수는 최소화 (side effect 발생)⇒ 어디서든 접근 가능해 편리하나, 다른 함수 혹은 로직에 의해 의도치 않은 변경이 발생할 수 있음 let, const를 주로 사용할 것 var는 블록 스코프를 무시하며, 재선언을 해도 에러를 내지 않음(같은 스코프에서 동일한 이름의 변수를 재선언하는 것은 버그를 유발) var로 선언한 전역 변수가 window 기능을 덮어씌워 내장 기능을 사용할 수 없게 만듦 선언 없는 변수 할당 금지 선언 키워드 없이 변수에 값을 할당하면 var와 같이 전역 변수로 작동⇒ 실수를 방지하기 위해 Strict Mode 사용가능 &#39;use strict&#39;;function showAge() { age = 90; // 여기서 에러발생} " }, { "title": "반복문", "url": "/posts/%EB%B0%98%EB%B3%B5%EB%AC%B8/", "categories": "JavaScript, basic", "tags": "JavaScript", "date": "2022-01-29 16:00:00 +0900", "snippet": "Achievement Goals 반복문을 활용하여 단순한 기능을 반복하여 수행할 수 있다. for문과 문자열, 숫자를 이용해 반복적으로 코드를 실행할 수 있다. 기본적인 for문을 응용하여 다양한 for문을 만들 수 있다. for와 while의 차이에 대해 설명할 수 있다. 반복문에 조건문을 적용할 수 있다. 이중 for문이 무엇인지 이해하고 활용할 수 있다. for 구문 반복할 조건을 초기화, 조건식, 증감문 순으로 넣어준다.ex) let sum = 1 ; for (let n = 2 ; // 초기화 2에서 시작 n ≤ 4 ; // 조건식 3, 4 까지 n= n + 1) { // 증감문 1씩 더한다 sum = sum + n ; // 반복할 내용 } console.log(sum); // 10while 구문 조건만 맞으면 계속 반복 반복할 조건 중, 초기화, 증감문은 따로, 조건식만 괄호 안에 넣어준다.ex) let sum = 1; let num = 2; // 초기화 while( n ≤ 4 ) { // 조건식 sum = sum + n; n = n + 1 ; 증감문; } console.log(sum); // 10 for문으로 할 수 있는 것은 while문으로도 모두 가능! (while문도 마찬가지) while은 주로 초기화 / 증감문이 필요없는 경우에 사용하면 유용이중 for문ex) for(let out = 1; out&amp;lt;5; out++) { for(let inner = 1; inner&amp;lt;5; inner++) { } return ${out}-${inner}; } ⇒ 1 -1 , 1-2, 1-3 처럼 나옴 ⇒ 바깥 for문이 한번 적용되면 안쪽 for문이 전부 작용해야 두번째 바깥 for문이 적용됨 (비유에는 시계가 좋음) ex) 11:01 / 11:02 / ..... / 12:00" }, { "title": "순열 조합", "url": "/posts/%EC%88%9C%EC%97%B4-%EC%A1%B0%ED%95%A9/", "categories": "Algorithms & CodingTest, Algorithms", "tags": "Permutation, Combination", "date": "2022-01-29 13:30:00 +0900", "snippet": "중복순열, 순열, 조합 중복순열 vs 순열(Permutation) vs 조합(Combination) 중복순열 중복 가능한 n개 중 r개를 선택하는 경우의 수 (순서 상관 있음) 순열 서로 다른 n개 중 r개를 선택하는 경우의 수 (순서 상관 있음) 조합 서로 다른 n개 중 r개를 선택하는 경우의 수 (순서 상관 없음) 중복순열 반복문 사용하여 구현하는 경우 // [a, b, c]의 아이템 중에서 r개를 선택하여 순서대로 나열하는 문제 let lookup = [a, b, c]; function permutation () { let result = []; // 전체 경우의 수를 담은 배열 // 뽑아야 하는 r 갯수만큼 반복문이 중첩된다 for(let i = 0; i &amp;lt; lookup.length; i++) { for(let j = 0; j &amp;lt; lookup.length; j++) { for(let k = 0; k &amp;lt; lookup.length; k++) { result.push([lookup[i], lookup[j], lookup[k]]); } } } return result; } 재귀를 사용하여 구현하는 경우 // [a, b, c]의 아이템 중에서 r개를 선택하여 순서대로 나열하는 문제 let lookup = [a, b, c]; function permutation (num, bucket = []) { let result = []; // 전체 경우의 수를 담은 배열 if(num === 0) { // 재귀 탈출문 result.push(bucket); return; // 임시 배열 bucket에 경우의 수가 각각 담기게 되는 데, // 이 때 num이 0이 되는 순간은 그 경우의 수에서 r개만큼 뽑았다는 것을 의미 } for(let i = 0; i &amp;lt; lookup.length; i++) { // recursive case permutation(num - 1, bucket.concat(lookup[i])) // push 외에 concat을 사용하는 이유? 각 method의 return value를 생각해보자 } return result; } 순열 반복문 사용하여 구현하는 경우 // [a, b, c]의 아이템 중에서 r개를 선택하여 순서대로 나열하는 문제 (중복 없이) let lookup = [a, b, c]; function permutation () { let result = []; // 전체 경우의 수를 담은 배열 // 뽑아야 하는 r 갯수만큼 반복문이 중첩된다 for(let i = 0; i &amp;lt; lookup.length; i++) { for(let j = 0; j &amp;lt; lookup.length; j++) { for(let k = 0; k &amp;lt; lookup.length; k++) { // 중복되는 값은 제외하기 위해 조건 작성 if(i === j || j === k || i === k) continue; result.push([lookup[i], lookup[j], lookup[k]]); } } } return result; } 재귀를 사용하여 구현하는 경우 let lookup = [a, b, c]; function permutation (arr, num, bucket = []) { let result = []; // 전체 경우의 수를 담은 배열 if(num === 0) { // 재귀 탈출문 result.push(bucket); return; } for(let i = 0; i &amp;lt; lookup.length; i++) { // recursive case let copiedArr = lookup.slice(); let pickOne = copiedArr.splice(i, 1); permutation(copiedArr, num - 1, bucket.concat(pickOne)) // 재귀 중 계속해서 선택된 요소를 뺀 상태의 배열이 인자로 들어가게 된다 // =&amp;gt; 중복되는 요소가 없는 경우의 수를 만들어 냄 } return result; } 조합 반복문 사용하여 구현하는 경우 // [a, b, c]의 아이템 중에서 r개를 선택 순서에 상관없이 나열하는 문제 let lookup = [a, b, c]; function permutation () { let result = []; // 뽑아야 하는 r 갯수만큼 반복문이 중첩된다 for(let i = 0; i &amp;lt; lookup.length; i++) { for(let j = i + 1; j &amp;lt; lookup.length; j++) { for(let k = j + 1; k &amp;lt; lookup.length; k++) { result.push([lookup[i], lookup[j], lookup[k]]); // index가 중첩되지 않게 담아 준다 } } } return result; } 재귀를 사용하여 구현하는 경우 // [a, b, c]의 아이템 중에서 r개를 선택하여 순서대로 나열하는 문제 let lookup = [a, b, c]; function permutation (arr, num, bucket = []) { let result = []; // 전체 경우의 수를 담은 배열 if(num === 0) { // 재귀 탈출문 result.push(bucket); return; } for(let i = 0; i &amp;lt; lookup.length; i++) { // recursive case let pickOne = lookup[i] let restArr = lookup.slice(i + 1) // 하나를 뽑고 나면 그 요소를 제거하여 같은 값이 들어가지 않게 해준다 permutation(restArr, num - 1, bucket.concat(pickOne)) } return result; } " }, { "title": "문자열", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4/", "categories": "JavaScript, basic", "tags": "JavaScript", "date": "2022-01-28 18:00:00 +0900", "snippet": "문자열Achievement Goals 문자열의 length라는 속성을 활용해 길이를 확인할 수 있다 문자열의 글자 하나하나에 접근할 수 있다 문자열을 합칠 수 있다 문자열을 원하는 만큼만 선택할 수 있다 영문을 모두 대, 소문자로 바꿀 수 있다 문자열 중 원하는 문자의 index를 찾을 수 있다 문자열 중 원하는 문자가 포함되어 있는지 알 수 있다 띄어쓰기( “ “ ) 로 문자열을 구분하여 배열을 바꿀 수 있다 위의 배열의 요소 사이에 띄어쓰기 ( “ “ )를 넣어 다시 문자열로 바꿀 수 있다 str.split( &quot; &quot; ).join( &quot; &quot; ) str[index] - index로 접근은 가능하나 쓸 수는 없음 (Read Only) 문자열은 새로 값을 할당하지 않는 한, 그 값이 바뀌지 않는다. ‘+’ 연산자 쓸 수 있음 ⇒ 다른 타입과 문자열 사이에 ‘+’ 사용하면 string 형식으로 변환 length: 문자열 길이를 반환 Method str.indexof( argument ) arguments : 찾고자 하는 문자열 return value : 처음으로 일치하는 문자열 , 없을 시 -1로 표기 str.includes( argument ) IE에서는 사용 불가 Boolean return / 대소문자 구분 필수 str.split(seperator) csv 형식 처리에 유용 (,) arguments: 분리 기준이 될 문자열 return value: 분리된 문자열이 포함된 ‘배열’ 줄 바꿈 먼저 한 뒤 처리 ⇒ csv.split( &#39;\\n&#39; ) let csv = ( ~~ ) let lines = csv.split(&#39;\\n&#39;) lines[0] // split된 csv의 첫째 줄 @ lines[0].split(&#39;,&#39;) // 첫째 줄의 ,로 분리 str.substring(start, end) arguments: 시작 index, 끝 index 음수는 0으로 취급 string method는 전부 immutable 즉, 원본이 변하지 않음. array method에서는 immutable / mutable 구분 잘할 것! 공백문자 : 탭 문자(\\t), Carrige return(\\r \\n) 및 return 문자 ( \\n )" }, { "title": "마크다운 문법", "url": "/posts/01-28-TIL-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EB%AC%B8%EB%B2%95/", "categories": "TIL, 2022-01", "tags": "TIL", "date": "2022-01-28 16:00:00 +0900", "snippet": "TIL 주로 사용할만한 MarkDown 문법 제목 # 제목 1 ## 제목 2 # 제목 1 ## 제목 2 설명 Sun : the star around which the earth orbits Sun the star around which the earth orbits Moon the natural satellite of the earth, visible by reflected light from the sun 토글 및 체크아웃 박스 &amp;lt;details&amp;gt; &amp;lt;summary&amp;gt;토글 목록&amp;lt;/summary&amp;gt; &amp;lt;div markdown=&quot;1&quot;&amp;gt; - [ ] 체크아웃 1 - [ ] 체크아웃 2 &amp;lt;/div&amp;gt; &amp;lt;/details&amp;gt; 토글 목록 체크아웃 1 체크아웃 2 텍스트 색상 &amp;lt;span style=&quot;color:blue&quot;&amp;gt;파란 글씨&amp;lt;/span&amp;gt; 파란 글씨 밑줄 &amp;lt;u&amp;gt;밑줄 텍스트&amp;lt;/u&amp;gt; 밑줄 텍스트 URL 링크 [설명할 내용](URL 주소) Naver 그림 링크 삽입 ![내용](이미지주소) 크기 수정 &amp;lt;img src=&quot;이미지 URL&quot; width=&quot;가로 사이즈&quot; height=&quot;세로 사이즈&quot;&amp;gt; 인용문 &amp;gt; 인용문 &amp;gt;&amp;gt; 인용문 속의 인용문 인용문 인용문 속의 인용문 테이블 왼쪽 정렬 |:---| 가운데 정렬 |:---:| 오른쪽 정렬 |---:| |**영화 제목**|**주연 배우**|*장르*| |:---:|---:|---| |명량|최민식|역사| |인터스텔라|매튜 맥커너히|SF| |돈룩업|레오나르도 디카프리오|코미디, SF| 영화 제목 주연 배우 장르 명량 최민식 역사 인터스텔라 매튜 맥커너히 SF 돈룩업 레오나르도 디카프리오 코미디, SF 프롬프트(Prompts) &amp;gt; `note` *타입 프롬프트* {: .prompt-note } &amp;gt; `warning` *타입 프롬프트* {: .prompt-warning } &amp;gt; `danger` *타입 프롬프트* {: .prompt-danger } note 타입 프롬프트 warning 타입 프롬프트 danger 타입 프롬프트 " }, { "title": "React Intro", "url": "/posts/React-Intro/", "categories": "React, React Intro", "tags": "React", "date": "2022-01-28 16:00:00 +0900", "snippet": "React IntroAchievement Goals React의 3가지 특성을 이해하고, 설명할 수 있다 JSX가 왜 명시적인지 이해하고, 바르게 작성할 수 있다 React Component의 필요성에 대해서 이해하고, 설명할 수 있다 create-react-app 으로 간단한 개발용 React 앱을 실행할 수 있다 React란? 프론트엔드 개발을 위한 JavaScript 오픈소스 라이브러리리액트의 3가지 특징 선언형 ( Declarative ) 한 페이지를 보여주기 위해 HTML / CSS / JS로 나눠 적기보다 하나의 파일에명시적으로 작성할 수 있게 JSX를 활용한 선언형 프로그래밍을 지향 명시적 : 코드를 자세히 분석하지 않고도, 코드의 의도를 분명히 알 수 있게 작동하는 방식 컴포넌트 기반 ( Component Based ) 컴포넌트 : 하나의 기능 구현을 위해 여러 종류의 코드를 하나로 묶어둔 것 컴포넌트로 분리하면 서로 독립적이고 재사용 가능하기 때문에, 기능 자체에 집중하여 개발 가능하며 유지 보수, 유닛 테스트에도 편리함 컴포넌트 (Component) : 구조와 동작에 대한 코드를 한 뭉치로 적은 코드셋 범용성 ( Learn Once, Write Anywhere ) JavaScript 프로젝트 어디서든 유연하게 사용할 수 있다 JSX (JavaScript XML) UI를 구성할 때 사용가능하게 JavaScript를 확장한 문법 브라우저가 바로 실행할 수 있는 코드는 아님 ⇒ JavaScript 코드로 변환 (Babel) Babel : JSX를 브라우저가 이해할 수 있는 JavaScript로 컴파일하는 것 JSX는 HTML이 아니기 때문에 컴파일 필수 JSX를 사용함으로써 코드의 복잡성을 줄이고, 이를 이해하기 쉽게 만들 수 있음 JSX 문법과 규칙 Opening tag와 Closing tag로 감싸주어야 함 (하나의 엘리먼트 안에 모든 엘리먼트 포함) &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;World&amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 엘리먼트 클래스 사용 시, className으로 표기 &amp;lt;div class = &quot;&quot; &amp;gt; X &amp;lt;div className=&quot;greeting&quot;&amp;gt; Hello! &amp;lt;/div&amp;gt; JavaScript 표현식 사용 시, 중괄호 이용 ( 사용하지 않으면 일반 텍스트로 인식 ) function App() { const name = &#39;Josh&#39;; return ( &amp;lt;div&amp;gt; Hello, **{name}** // 반드시 {} 사용 &amp;lt;/div&amp;gt; ); } 사용자 정의 컴포넌트는 대문자로 시작 ( PascalCase ) function Hello() { return &amp;lt;div&amp;gt;Hello!&amp;lt;/div&amp;gt;; } function HelloWorld() { return &amp;lt;Hello /&amp;gt;; } 조건부 렌더링에서는 삼항연산자 사용 &amp;lt;div&amp;gt; { (1+1 === 2) ? (&amp;lt;p&amp;gt;정답&amp;lt;/p&amp;gt;) : (&amp;lt;p&amp;gt;탈락&amp;lt;/p&amp;gt;) } &amp;lt;/div&amp;gt; 여러개의 HTML 엘리먼트를 표시할 때, map() 함수 사용 const posts = { *** }; function Blog() { const content = posts.map((post) =&amp;gt; &amp;lt;div key={post.id}&amp;gt; // **map 사용시 반드시 &quot;key&quot; JSX 속성을 넣어야함** &amp;lt;h3&amp;gt;{post.title}&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{post.content}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); return ( &amp;lt;div&amp;gt; {content} &amp;lt;/div&amp;gt; ); } map을 이용한 반복// 배열의 각 요소(post)를 특정 논리(postToElement)에 의해 다른 요소로 지정1)function Blog () { const postToElement = (post) =&amp;gt; { &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;{post.title}&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{post.content}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); const blogs = posts.map(postToElement); return &amp;lt;div className=&quot;post-wrapper&quot;&amp;gt;{blogs}&amp;lt;/div&amp;gt;;}/* return 문 안에서 map 메소드를 사용할 수는 없을까요?사용할 수 있습니다. JSX를 사용하면 중괄호 안에 모든 표현식을 포함할 수 있기 때문에map 메소드의 결과를 return문 안에 인라인으로 처리할 수 있습니다. 코드 가독성을 위해 변수로 추출할지 아니면 인라인에 넣을지는 개발자가 판단해야 할 몫입니다.*/ Key 속성/*key 속성값은 가능하면 데이터에서 제공하는 id를 할당해야 합니다. key 속성값은 id와 마찬가지로 변하지 않고, 예상 가능하며, 유일해야 하기 때문입니다. 고유한 id가 없는 경우에만 배열 인덱스를 넣어서 해결할 수 있습니다*/function Blog() { const blogs = posts.map((post) =&amp;gt; { &amp;lt;div key={post.id}&amp;gt; &amp;lt;h3&amp;gt;{post.title}&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{post.content}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; }); return &amp;lt;div className=&quot;post-wrapper&quot;&amp;gt;{blogs}&amp;lt;/div&amp;gt;;} " }, { "title": "변수, 타입, 함수, 조건문", "url": "/posts/%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85-%ED%95%A8%EC%88%98-%EC%A1%B0%EA%B1%B4%EB%AC%B8/", "categories": "JavaScript, basic", "tags": "JavaScript", "date": "2022-01-28 16:00:00 +0900", "snippet": "변수(Variable)Achievement Goals 자바스크립트에서 변수의 선언과 값의 할당에 대해서 설명할 수 있다. 변수 선언과 값 할당에 사용되는 용어에 대해서 정확하게 알 수 있다. =가 “같다”라는 의미가 아니라 할당연산자임을 이해할 수 있다. num = num + 1이 ‘같다’라는 의미가 아니라 값을 할당하는 것임을 설명할 수 있다. 선언 = 메모리 공간을 만들고 / 할당 = 공간에 데이터를 저장 Programming = Data Processing 데이터 보관함 = 메모리 (보관함의 크기는 동일) 각 보관함의 이름 = 변수 표현식에서 결과물을 다시 변수로 담을 수도 있다. 변수는 동일한 변수를 이용해 대입할 수 있다. let sum; // 선언 sum = 2; // 할당 타입(Type)Achievement Goals 자바스크립트에서 원시 자료형과 참조 자료형이 무엇인지 알 수 있다. 원시 자료형 string, number, boolean, undefined의 의미를 이해할 수 있다. 타입마다 다른 속성과 메소드가 있다는 것을 이해할 수 있다. typeof 를 활용하여 특정 값의 타입을 확인할 수 있다. 비교 시 엄밀한 비교의 필요성을 이해할 수 있다. 원시 자료형 - 객체가 아니면서 method를 가지지 않는 6가지의 타입(ex) string, number, boolean, undefined, symbol, bigint, (null) 원시 자료형은 모두 ‘하나’의 데이터를 담고 있다. 참조 자료형 - 원시 자료형이 아닌 모든 것(ex) 객체, 배열, 함수함수(Function)Achievement Goals 함수 선언을 위해 필요한 keyword, name, parameter, body에 대해 이해할 수 있다. 함수 선언과 호출의 기초적인 작동 원리를 이해할 수 있다. 함수의 결과값이 변수에 할당되어 담기는 과정을 이해할 수 있다. 함수의 호출과 리턴에 대해서 이해하고, 실제 코드로 작성하여 활용할 수 있다. 함수 그 자체와 함수의 호출을 구분하여 사용할 수 있다. 매개변수(parameter)와 전달인자(argument)를 구분하여 사용할 수 있다. 같은 기능을 하는 함수를 선언식, 표현식, 화살표 함수로 바꾸어 표현할 수 있다. 함수는 호출 후에 반드시 돌아온다(return) / function과 return은 항상 같이 함수 선언 함수 호출 함수 선언 방법 3가지 (함수 선언식 / 함수 표현식 / 화살표 함수) 화살표 함수의 경우 함수식이 한줄인 경우에는 중괄호{}와 return 생략가능! 조건문Achievement Goals truthy와 falsy가 조건문에서 작동하는 방식을 이해할 수 있다. 비교연산자를 통한 엄격한 비교에 대해 이해할 수 있다. if와 else if, else를 이해하고 무리없이 활용할 수 있다. 논리연산자를 통해 복잡한 조건을 간결하게 작성할 수 있다. 복잡한 조건문을 활용하여 실생활에서 마주하는 문제를 해결하는 알고리즘을 구현한다. Boolean 타입에 대한 이해 필요 (비교의 결과는 늘 true or false = Boolean) 조건문은 true false를 판별하는 기준을 세우는 것 (비교연산자 필요) 비교연산자 &amp;gt; , &amp;lt; , ≥ , ≤ , ===, !== === : 값과 타입을 모두 비교 == : 값만을 비교 = : 할당연산자 ( == or != )은 타입을 엄격하게 비교하지 않기때문에 사용하면 안됨 if (조건1) 조건1이 통과할 경우 else if (조건2) 조건1이 통과하지 않을 경우 else 모든 조건이 통과하지 않을 경우 다중 if 문에서는 각각의 if 에 return 값이 필요 if(~~) { if(~~) { return true } return false } 두가지 조건이 한번에 적용되는 경우 논리연산자 사용 &amp;amp;&amp;amp;(and), ||(or) !isStudent &amp;amp;&amp;amp; isFemale; ⇒ 학생이 아니면서, 여성일 때 true || true // true true || false // true false || false // false true &amp;amp;&amp;amp; true // true true &amp;amp;&amp;amp; false // false false &amp;amp;&amp;amp; false // false!(not) !undefined // true (undefined는 false로 취급) !&#39;Hello&#39; // false (String 타입은 true로 취급) !false = true / !(2&amp;gt;3) = true 기억해야할 6가지 falsy value if(false, null, undefined, 0, NaN, &#39; &#39;) MECE 기법 중복되는 항목을 기준으로 조건의 순서를 우선적으로 매기는 것이 중요하다. " }, { "title": "MVC(2)", "url": "/posts/01-27-TIL-MVC(2)/", "categories": "TIL, 2022-01", "tags": "TIL", "date": "2022-01-27 23:00:00 +0900", "snippet": "sprint Repository: im-sprint-shortly-mvc sequelize-cli를 이용해 mvc pattern을 구현하는 법 npx sequelize-cli init 기본 세팅을 진행, 아래와 같은 폴더들이 생성됨 config: DB와 연결하는 정보를 담은 폴더. sprint에서는 .json으로 되어있으나 js파일로 dotenv 모듈을 이용해 환경변수를 불러와 연결하는 것도 가능 models: 필요한 model을 생성해 관리하는 폴더 migrations: 스키마의 테이블 필드의 타입 정보가 담겨 있는 파일로 구성(db:migrate 및 undo 명령어 시 호출되는 up, down method 포함, queryInterface API 참조) seeders: 필드에 맞는 데이터를 레코드로 삽입할 수 있는 파일로 구성 npx sequelize-cli model:generate --name [name] --attributes [field][dataType] 주어진 명령어대로 model 생성 및 XXXXXXXXXXXXXX-create-[name].js과 같은 migration 파일 생성 npx sequelize-cli db:migrate dataType 설정에 맞춘 Field를 생성해주는 명령어 (optional) npx sequelize-cli seed:generate --name, db:seed:all bulk insert할 seed 파일 존재 시 레코드 삽입 Migration Skeleton 형식 module.exports = { up: (queryInterface, Sequelize) =&amp;gt; { // db:migrate }, down: (queryInterface, Sequelize) =&amp;gt; { // db:migrate:undo } } model 형식 &#39;use strict&#39;; const { Model } = require(&#39;sequelize&#39;); module.exports = (sequelize, DataTypes) =&amp;gt; { class user extends Model { // Model Class를 확장하여 sequelize query method 사용 /** * Helper method for defining associations. * This method is not a part of Sequelize lifecycle. * The `models/index` file will call this method automatically. */ static associate(models) { // 참조하는 다른 model(table)과의 관계 설정 / hasOne, hasMany, belongsTo this.hasMany(models.url) } } user.init({ name: DataTypes.STRING }, { sequelize, modelName: &#39;user&#39;, }); return user; }; Associations을 이용한 Join Table 구현 모델 생성 cli 이용해서 user 모델 생성 해당하는 model 폴더 내의 파일에 관계 설정을 해줍니다. url파일에서도 user와 관계 설정 user와 url에서도 관계 설정 마이그레이션 파일을 작성해야하는데 skeleton 비어있는 템플릿 파일 생성하는 cli 명령어 공식문서 참조해서 queryInterface 메소드를 이용해서 userId 컬럼 생성 userId 컬럼에 FK 제약 생성 마이그레이션 → 두개의 파일이 마이그레이션 됨 (1. user테이블 생성, 2. userId FK 생성)" }, { "title": "MVC", "url": "/posts/01-26-TIL-MVC/", "categories": "TIL, 2022-01", "tags": "TIL", "date": "2022-01-26 23:00:00 +0900", "snippet": "sprint MVC 구조 Batch mode에서 schema, seed 파일 적용하는 방법 mysql -u root -p &amp;lt; PATH/[schema or seed].sql -D[database] // -D 커맨드는 지정한 파일을 import할 데이터베이스를 선택하는 명령어 Node.js mysql 모듈로 bulk insert 하는 방법 // Bulk insert const sql = &quot;INSERT INTO customers (name, address) VALUES ?&quot;; const params = [ [&quot;John&quot;, &quot;Highway 71&quot;], [&quot;Peter&quot;, &quot;Lowstreet 4&quot;], [&quot;Amy&quot;, &quot;Apple st 652&quot;], [&quot;Hannah&quot;, &quot;Mountain 21&quot;], [&quot;Michael&quot;, &quot;Valley 345&quot;], [&quot;Sandy&quot;, &quot;Ocean blvd 2&quot;], [&quot;Betty&quot;, &quot;Green Grass 1&quot;], [&quot;Richard&quot;, &quot;Sky st 331&quot;], [&quot;Susan&quot;, &quot;One way 98&quot;], [&quot;Vicky&quot;, &quot;Yellow Garden 2&quot;], [&quot;Ben&quot;, &quot;Park Lane 38&quot;], ]; con.query(sql, [params], function (err, result) { if (err) throw err; console.log(&quot;Number of records inserted: &quot; + result.affectedRows); }); // Result Object { fieldCount: 0, affectedRows: 14, insertId: 0, // Insert로 생성되는 insertId를 PK로 사용하여 조인 테이블에서 FK로 참조할 수 있음 serverStatus: 2, warningCount: 0, message: &#39;\\&#39;Records:14 Duplicated: 0 Warnings: 0&#39;, protocol41: true, changedRows: 0 } FK(외래키)가 존재하는 테이블의 경우, 테이블 DELETE 및 TRUNCATE 실행 시, Cannot truncate a table referenced in a foreign key constraint 오류가 발생 해결법 SET FOREIGN_KEY_CHECKS = 0; -- Disable foreign key checking. TRUNCATE TABLE [Table_name]; SET FOREIGN_KEY_CHECKS = 1; -- Enable foreign key checking. " }, { "title": "보드게임", "url": "/posts/BoardGame/", "categories": "Algorithms & CodingTest, CodingTest", "tags": "", "date": "2022-01-26 20:00:00 +0900", "snippet": "/* ? N * N의 크기를 가진 보드판 위에서 게임을 하려고 합니다. 게임의 룰은 다음과 같습니다. 1. 좌표 왼쪽 상단(0, 0)에 말을 놓는다. 2. 말은 상, 하, 좌, 우로 이동할 수 있고, 플레이어가 조작할 수 있다. 3. 조작의 기회는 딱 한 번 주어진다. 4. 조작할 때 U, D, L, R은 각각 상, 하, 좌, 우를 의미하며 한 줄에 띄어쓰기 없이 써야 한다. 5. 한 번 움직일 때마다 한 칸씩 움직이게 되며, 그 칸 안의 요소인 숫자를 획득할 수 있다. 6. 방문한 곳을 또 방문해도 숫자를 획득할 수 있다. 7. 보드 밖을 나간 말은 OUT 처리가 된다. 8. 칸 안의 숫자는 0 또는 1이다. 9. 단, 좌표 왼쪽 상단(0, 0)은 항상 0이다. * 획득한 숫자를 합산하여 숫자가 제일 큰 사람이 이기게 된다. * 보드판이 담긴 board와 조작하려고 하는 문자열 operation이 주어질 때, 말이 해당 칸을 지나가면서 획득한 숫자의 합을 구하는 함수를 작성하세요. ! 만약, 말이 보드 밖으로 나갔다면 즉시 OUT 을 반환 인자 1: board - number 타입의 2차원 배열 / 2 &amp;lt;= board.length &amp;lt;= 1,000 인자 2: operation - string 타입의 대문자 영어가 쓰여진 문자열 / 1 &amp;lt;= operation.length &amp;lt;= board.length * 2 U, L, D, R 이외의 문자열은 없습니다. */function boardGame(board, operation) { const DIR = { &#39;U&#39;: [-1, 0], &#39;D&#39;: [1, 0], &#39;L&#39;: [0, -1], &#39;R&#39;: [0, 1] } const N = board.length const isValid = (y, x) =&amp;gt; y &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; N &amp;amp;&amp;amp; x &amp;lt; N; let Y = 0, X = 0, score = 0; for(let i = 0; i &amp;lt; operation.length; i++) { const [dY, dX] = DIR[operation[i]]; Y += dY; X += dX; if(!isValid(Y, X)) return &#39;OUT&#39;; score += board[Y][X]; } return score;}const board1 = [ [0, 0, 0, 1], [1, 1, 1, 0], [1, 1, 0, 0], [0, 0, 0, 0] ]const operation1 = &#39;RRDLLD&#39;const output1 = boardGame(board1, operation1);console.table(board1);console.log(`위 보드에서 말을 &#39;${operation1}&#39;으로 조작해 획득한 점수는 ${output1}점 입니다`)" }, { "title": "그리디 알고리즘", "url": "/posts/Greedy/", "categories": "Algorithms & CodingTest, Algorithms", "tags": "Greedy Algorithm", "date": "2022-01-25 22:00:00 +0900", "snippet": " 탐욕 알고리즘: 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법/* ? 1. 짐의 무게가 [70kg, 50kg, 80kg, 50kg]이고 박스의 무게 제한이 100kg인 경우, 모든 짐을 옮기기 위한 최소 횟수 인자 1: stuff - Number 타입의 40 이상 240 이하의 자연수를 담은 배열 인자 2: limited - Number 타입의 40 이상 240 이하의 자연수 */function movingStuff(stuff, limited) { let moveCount = 0; let left = 0, right = 0; while(left &amp;lt; right) { // 한 번에 두 개 이상을 들 수 있게 양측에서 접근 if(stuff[left] + stuff[right] &amp;lt;= limited) { left++; right--; moveCount++; } else { right--; } } return stuff.length - moveCount// 모든 짐을 한개씩만 옮긴 경우 = 짐의 갯수}let output = movingStuff([70, 50, 80, 50], 100);console.log(`1. 짐을 모두 옮기는 데 필요한 최소 횟수는 ${output}번입니다`);/* ? 2. 가지고 있는 동전 1원, 5원, 10원, 50원, 100원, 500원을 최소한의 갯수로 주어진 거스름 돈 만들기 인자: k - number 타입 1 &amp;lt;= k &amp;lt;= 100,000,000 number 타입의 거스름돈 K원을 만드는데 필요한 동전 개수의 최솟값을 반환 */function partTimejob(k) { let coins = [500, 100, 50, 10, 5, 1]; let count = 0; for(let i = 0; i &amp;lt; coins.length; i++) { let sum = Math.floor(k / coins[i]) k = k - (sum * coins[i]) count += sum } return count}let money = 4972let output2 = partTimejob(money);console.log(`2. ${money}원을 거스르는 데 필요한 동전의 최소 갯수는 ${output2}개 입니다`);" }, { "title": "쿠키", "url": "/posts/01-24-TIL-%EC%BF%A0%ED%82%A4/", "categories": "TIL, 2022-01", "tags": "TIL", "date": "2022-01-24 23:00:00 +0900", "snippet": "인증 보안 클론코딩 Repository: Nodejs (생활코딩)const http = require(&#39;http&#39;);const cookie = require(&#39;cookie&#39;); // 쿠키 모듈http.createServer((request, response) =&amp;gt; { let cookies = {} if (request.headers.cookie !== undefined) { // Set-Cookie가 선행되면 cookie값이 저장되는 장소 cookies = cookie.parse(request.headers.cookie); // cookie값 객체화 } console.log(cookies.yummy_cookie); response.writeHead(200, { &#39;Set-Cookie&#39;: [ &#39;yummy_cookie=choco&#39;, &#39;tasty_cookie=strawberry&#39;, `Permanent=cookies; Max-Age=${60 * 60}`, &#39;Secure=Secure; Secure&#39;, &#39;HttpOnly=HttpOnly; HttpOnly&#39;, &#39;Path=Path; Path=/cookie&#39; ] }) response.end(&#39;Cookie!!&#39;);}).listen(3000); 클라이언트에서 특정 사이트 접속 =&amp;gt; 사이트의 서버에서 일방적으로 쿠키를 응답 Header에 담아 전송Set-Cookie: 쿠키 생성해서 클라이언트에 쿠키 저장하게 해줌 새로고침 =&amp;gt; 요청에다가 앞서 설정된 Cookie 값을 담아 서버로 전송(Application 탭에서 확인 가능) 쿠키에 SessionID / 언어 정보 등 다양한 정보가 저장 =&amp;gt; 보안 사고에 유의 Session 쿠키: 웹 브라우저를 종료하면 사라지는 휘발성 쿠키, 기간 옵션 설정하지 않음 Permanent 쿠키: 웹 브라우저를 꺼도 사라지지 않는 영속성 쿠키, Expires 또는 Max-Age를 설정 보안 options Secure: Set-Cookie로 설정하면 해당 쿠키는 request Cookie에 저장되지 않음 HttpOnly: 쿠키 탈취 방지를 위해 javaScript로는 쿠키에 접근할 수 없게 해주는 옵션 기타 option Path: 지정한 path에서만 쿠키 전송 Domain: 지정한 Domain에서만 쿠키 전송 로그인 (쿠키에 로그인 정보를 담는 것은 보안상 매우 위험하므로 전체 흐름만 파악할 것) =&amp;gt; Session 로그인 실행(버튼 등 UI로 구현)하면 Set-Cookie로 email(id), password 값을 저장 로그인 여부를 확인(req.headers.cookie =&amp;gt; cookie.parse)parse의 결과에 email, password 정보가 담겨있으면 로그인 상태 변화 isLogin = false =&amp;gt; true 로그인 상태에 따른 UI 조정 로그아웃 Set-Cookie로 email, password에 빈 값을 주고, Max-Age=0으로 설정 =&amp;gt; 수명이 0이기에 쿠키가 바로 삭제됨 " } ]
